<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Audio Library Galaxy V8 - Advanced Dynamics</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://unpkg.com/wavesurfer.js@7"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #000000;
            overflow: hidden;
            color: #ffffff;
        }

        /* Global rule: Make ALL range sliders draggable across entire page */
        input[type="range"] {
            touch-action: pan-x !important;
            pointer-events: auto !important;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: fixed;
            top: 0;
            left: 0;
        }

        /* Crosshair for aiming */
        .crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            z-index: 500;
            pointer-events: none;
        }

        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.6);
        }

        .crosshair::before {
            top: 50%;
            left: 0;
            width: 100%;
            height: 2px;
            transform: translateY(-50%);
        }

        .crosshair::after {
            left: 50%;
            top: 0;
            height: 100%;
            width: 2px;
            transform: translateX(-50%);
        }

        /* Top UI Bar */
        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 30px;
            z-index: 1000;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .top-bar h1 {
            font-size: 1.3em;
            font-weight: 600;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .top-bar-actions {
            display: flex;
            gap: 15px;
        }

        .btn {
            padding: 8px 20px;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.4);
            border-radius: 6px;
            color: #667eea;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn:hover {
            background: rgba(102, 126, 234, 0.4);
            border-color: #667eea;
            color: #ffffff;
        }

        /* Database Dropdown Selector */
        .db-dropdown {
            position: relative;
            display: inline-block;
        }

        .db-dropdown-btn {
            padding: 8px 15px;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.5);
            border-radius: 6px;
            color: #ccc;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .db-dropdown-btn:hover {
            background: rgba(102, 126, 234, 0.3);
            border-color: #667eea;
        }

        .db-dropdown-content {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 5px;
            background: rgba(20, 20, 20, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 6px;
            padding: 8px;
            min-width: 200px;
            z-index: 2000;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }

        .db-dropdown.active .db-dropdown-content {
            display: block;
        }

        .db-dropdown-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            color: #ccc;
            font-size: 12px;
        }

        .db-dropdown-item:hover {
            background: rgba(102, 126, 234, 0.2);
        }

        .db-dropdown-item input[type="checkbox"] {
            cursor: pointer;
        }

        .btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: #ffffff;
        }

        .btn.primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        /* Stats Overlay */
        .stats-overlay {
            position: fixed;
            top: 80px;
            left: 20px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px 20px;
            z-index: 1000;
            font-size: 12px;
            min-width: 200px;
        }

        .stats-overlay .stat-row {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 8px;
        }

        .stats-overlay .stat-row:last-child {
            margin-bottom: 0;
        }

        .stats-overlay .stat-label {
            color: #888;
        }

        .stats-overlay .stat-value {
            color: #667eea;
            font-weight: 600;
        }

        /* Controls hint */
        .controls-hint {
            position: fixed;
            bottom: 140px;
            left: 20px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px 20px;
            z-index: 1000;
            font-size: 11px;
            color: #888;
        }

        .controls-hint h3 {
            font-size: 12px;
            color: #667eea;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .controls-hint div {
            margin-bottom: 5px;
        }

        .controls-hint kbd {
            background: rgba(255, 255, 255, 0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
            color: #fff;
        }

        /* Bottom Audio Player */
        .bottom-player {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            background: rgba(15, 15, 15, 0.95);
            backdrop-filter: blur(20px);
            border-top: none;
            display: flex;
            align-items: center;
            padding: 10px 20px;
            gap: 20px;
            z-index: 1000;
            transform: translateY(100%);
            transition: transform 0.3s ease;
        }

        .bottom-player.active {
            transform: translateY(0);
        }

        /* Multi-Stem Player - Stacked Player Bars */
        .multi-stem-player {
            position: fixed;
            bottom: 100px;
            left: 0;
            right: 0;
            background: transparent;  /* Transparent so individual bars show through */
            backdrop-filter: none;
            border-top: none;
            border-bottom: none;
            z-index: 998;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease, opacity 0.3s ease;
            margin: 0;
            padding: 0;
            gap: 0;  /* No gap between stem bars */
        }

        .multi-stem-player.collapsed {
            transform: translateY(calc(100% + 100px));  /* Move down by its own height PLUS bottom player height */
            opacity: 0;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .multi-stem-player {
                bottom: 100px;
            }
        }

        /* First stem player bar - seamless attachment to bottom player */
        .stem-player-bar:first-child {
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        /* Push mode-controls up when multi-stem player is visible */
        .mode-controls, .mode-controls-left {
            transition: bottom 0.3s ease, max-height 0.3s ease, top 0.3s ease;
        }

        body.multi-stem-active .mode-controls,
        body.multi-stem-active .mode-controls-left {
            top: auto;  /* Unset top when using bottom positioning */
            bottom: calc(100px + var(--multi-stem-height, 0px));
            max-height: calc(100vh - 120px - var(--multi-stem-height, 0px));
        }

        /* Ensure proper height when NOT in multi-stem mode */
        body:not(.multi-stem-active) .mode-controls,
        body:not(.multi-stem-active) .mode-controls-left {
            bottom: auto;  /* Ensure bottom is not set */
            top: 20px;     /* Explicitly set top */
        }

        /* Each stem player bar - same height as bottom-player */
        .stem-player-bar {
            height: 100px;
            background: rgba(15, 15, 15, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            display: flex;
            align-items: center;
            padding: 10px 20px;
            gap: 15px;
            margin: 0;
        }

        .stem-player-bar:last-child {
            border-bottom: none;
        }

        /* Stem-specific player controls */
        .stem-player-controls {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-shrink: 0;
        }

        .stem-player-btn {
            min-width: 32px;
            height: 32px;
            padding: 0 6px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #888;
            transition: all 0.2s;
            font-size: 11px;
            font-weight: 600;
        }

        .stem-player-btn:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: rgba(255, 255, 255, 0.25);
            color: #aaa;
        }

        .stem-player-btn.active {
            background: rgba(102, 126, 234, 0.2);
            border-color: #667eea;
            color: #667eea;
        }

        .stem-player-btn.play-pause {
            width: 38px;
            height: 38px;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.7) 0%, rgba(118, 75, 162, 0.7) 100%);
            border: none;
            border-radius: 50%;
            font-size: 16px;
            color: #fff;
        }

        .stem-player-btn.play-pause:hover {
            transform: scale(1.05);
            box-shadow: 0 3px 12px rgba(102, 126, 234, 0.3);
        }

        .stem-player-waveform {
            flex: 1;
            height: 50px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 4px;
            overflow: visible;
            position: relative;
        }

        .stem-player-info {
            display: flex;
            flex-direction: column;
            gap: 3px;
            min-width: 200px;
            max-width: 280px;
            flex-shrink: 0;
        }

        .stem-player-filename {
            color: #ddd;
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stem-player-time {
            color: #888;
            font-size: 10px;
        }

        .stem-player-volume {
            display: flex;
            align-items: center;
            gap: 8px;
            min-width: 120px;
        }

        .stem-player-volume span {
            color: #888;
            font-size: 11px;
        }

        .stem-player-volume input[type="range"] {
            flex: 1;
            height: 3px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 2px;
            outline: none;
            cursor: pointer;
            touch-action: pan-x !important;
            pointer-events: auto !important;
        }

        .player-controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-shrink: 0;
        }

        .player-btn {
            min-width: 36px;
            height: 36px;
            padding: 0 8px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #999;
            transition: all 0.2s;
            font-size: 12px;
            font-weight: 600;
        }

        .player-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.3);
            color: #fff;
        }

        .player-btn.active {
            background: rgba(102, 126, 234, 0.3);
            border-color: #667eea;
            color: #667eea;
        }

        .player-btn.play-pause {
            width: 44px;
            height: 44px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50%;
            font-size: 20px;
            color: #fff;
        }

        .player-btn.play-pause:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
        }

        .player-waveform {
            flex: 1;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            overflow: visible;
            position: relative;
        }

        .player-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            min-width: 250px;
            max-width: 350px;
            flex-shrink: 0;
        }

        .player-filename {
            color: #fff;
            font-size: 13px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-metadata {
            color: #888;
            font-size: 11px;
        }

        .player-time {
            color: #999;
            font-size: 11px;
        }

        /* File info tooltip */
        .file-tooltip {
            position: fixed;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(102, 126, 234, 0.5);
            border-radius: 8px;
            padding: 12px 16px;
            z-index: 2000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 12px;
            max-width: 300px;
        }

        .file-tooltip.active {
            opacity: 1;
            pointer-events: auto;
        }

        .tooltip-close-btn {
            position: absolute;
            bottom: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.7);
            font-size: 12px;
            line-height: 1;
            transition: all 0.2s;
            pointer-events: auto;
        }

        .tooltip-close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            color: rgba(255, 255, 255, 1);
        }

        .tooltip-close-btn:active {
            transform: scale(0.9);
        }

        .file-tooltip .tooltip-title {
            font-weight: 600;
            color: #667eea;
            margin-bottom: 6px;
            font-size: 13px;
        }

        .file-tooltip .tooltip-metadata {
            color: #999;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .file-tooltip .tooltip-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-top: 6px;
        }

        .file-tooltip .tag-chip {
            padding: 2px 8px;
            background: rgba(102, 126, 234, 0.2);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 10px;
            font-size: 10px;
            color: #667eea;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 0.5s;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid rgba(102, 126, 234, 0.2);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 20px;
            color: #888;
            font-size: 14px;
        }

        /* Tag Color Legend */
        .tag-legend {
            position: fixed;
            top: 200px;
            left: 20px;
            background: rgba(10, 10, 10, 0.85);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px 20px;
            z-index: 1000;
            font-size: 11px;
            min-width: 200px;
            max-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        #tagLegendContent {
            max-height: 300px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #tagLegendContent::-webkit-scrollbar {
            width: 4px;
        }

        #tagLegendContent::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
        }

        #tagLegendContent::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 2px;
        }

        .tag-legend h3 {
            font-size: 12px;
            color: #667eea;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tag-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .tag-legend-item:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .tag-legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .tag-legend-name {
            color: #ccc;
            font-size: 11px;
            flex: 1;
        }

        .tag-legend-count {
            color: #667eea;
            font-size: 10px;
            font-weight: 600;
        }

        /* Tag Filter Panel (Library-style) */
        .tag-filter-panel {
            position: fixed;
            top: 200px;
            left: 20px;
            min-width: 200px;
            max-width: 250px;
            max-height: 500px;
            background: rgba(10, 10, 10, 0.85);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px 15px;
            color: #fff;
            font-size: 11px;
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            z-index: 999;
            overflow-y: auto;
        }

        .tag-filter-panel.hidden {
            display: none;
        }

        .tag-filter-panel h3 {
            font-size: 11px;
            color: #667eea;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .tag-filter-panel.collapsed {
            max-height: 50px;
            overflow: hidden;
        }

        .tag-filter-panel.collapsed .tag-filter-content {
            display: none;
        }

        .tag-legend.collapsed {
            max-height: 50px;
            overflow: hidden;
        }

        .tag-legend.collapsed #tagLegendContent,
        .tag-legend.collapsed .search-container,
        .tag-legend.collapsed > div[style*="display: flex"] {
            display: none !important;
        }

        .collapse-btn {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            cursor: pointer;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            transition: all 0.2s;
        }

        .collapse-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .filter-mode-buttons {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }

        .mode-btn {
            flex: 1;
            padding: 4px 6px;
            background: transparent;
            border: 1px solid;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: 600;
            transition: all 0.2s;
        }

        .mode-btn.can-have {
            border-color: #3b82f6;
            color: #3b82f6;
        }

        .mode-btn.can-have.active {
            background: #3b82f6;
            color: white;
        }

        .mode-btn.must-have {
            border-color: #10b981;
            color: #10b981;
        }

        .mode-btn.must-have.active {
            background: #10b981;
            color: white;
        }

        .mode-btn.exclude {
            border-color: #ef4444;
            color: #ef4444;
        }

        .mode-btn.exclude.active {
            background: #ef4444;
            color: white;
        }

        .tag-filter-search {
            position: relative;
            margin-bottom: 8px;
        }

        .tag-filter-search input {
            width: 100%;
            padding: 6px 26px 6px 8px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            color: #fff;
            font-size: 10px;
        }

        .tag-filter-search .search-icon {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.5;
            font-size: 10px;
        }

        .tag-buttons-container {
            max-height: 250px;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-wrap: wrap;
            gap: 3px;
            padding: 4px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .tag-buttons-container::-webkit-scrollbar {
            width: 4px;
        }

        .tag-buttons-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 2px;
        }

        .tag-buttons-container::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 2px;
        }

        .tag-filter-button {
            padding: 3px 6px;
            background: rgba(255, 255, 255, 0.1);
            color: #ccc;
            border: 1px solid transparent;
            border-radius: 10px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 500;
            transition: all 0.2s;
            white-space: nowrap;
            flex: 0 0 auto;
            max-width: calc(50% - 2px);
        }

        .tag-filter-button:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .tag-filter-button.can-have {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.2);
            color: #6ba3ff;
        }

        .tag-filter-button.must-have {
            border-color: #10b981;
            background: rgba(16, 185, 129, 0.2);
            color: #4ade80;
        }

        .tag-filter-button.exclude {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.2);
            color: #f87171;
        }

        .active-filters-display {
            font-size: 9px;
            color: #999;
            padding: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            min-height: 24px;
            line-height: 1.3;
        }

        /* Search bar styling */
        .search-container {
            position: relative;
            margin-bottom: 12px;
        }

        .search-input {
            width: 100%;
            padding: 8px 32px 8px 10px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(102, 126, 234, 0.3);
            border-radius: 6px;
            color: #fff;
            font-size: 11px;
            outline: none;
            transition: border-color 0.2s;
        }

        .search-input:focus {
            border-color: rgba(102, 126, 234, 0.6);
        }

        .search-input::placeholder {
            color: rgba(255, 255, 255, 0.4);
        }

        .search-icon {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(255, 255, 255, 0.5);
            pointer-events: none;
            font-size: 12px;
        }

        /* Visualization Mode Controls */
        .mode-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            min-width: 220px;
            max-width: 240px;
            max-height: calc(100vh - 240px);
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        /* Options 2 - LEFT SIDE (exact duplicate, different position) */
        .mode-controls-left {
            position: fixed;
            top: 20px;
            left: 20px;  /* LEFT instead of right */
            right: auto;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            min-width: 220px;
            max-width: 240px;
            max-height: calc(100vh - 240px);
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        /* Smaller screens need even more conservative height */
        @media (max-height: 700px) {
            .mode-controls, .mode-controls-left {
                max-height: calc(100vh - 260px);
            }
        }

        @media (max-height: 600px) {
            .mode-controls, .mode-controls-left {
                max-height: calc(100vh - 280px);
            }
        }

        .mode-controls.dragging {
            transition: none;
            opacity: 0.9;
        }

        .mode-controls::-webkit-scrollbar {
            width: 6px;
        }

        .mode-controls::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .mode-controls::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 3px;
        }

        .mode-controls::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        .mode-controls h3 {
            font-size: 11px;
            color: #667eea;
            margin-bottom: 6px;
            margin-top: 0;
            padding: 4px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .mode-controls h3:hover {
            color: #8899ff;
        }

        .mode-controls h3::after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.2s;
        }

        .mode-controls h3.collapsed::after {
            transform: rotate(-90deg);
        }

        /* Options Menu Title Bar */
        .options-title-bar {
            position: sticky;
            top: -15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            margin: -15px -15px 15px -15px;
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: default;
            user-select: none;
            z-index: 10;
        }

        .options-title-bar:active {
            cursor: default;
        }

        .options-title-bar:hover {
            cursor: default;
        }

        .options-title-bar h2 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .options-collapse-icon {
            font-size: 18px;
            color: rgba(255, 255, 255, 0.8);
            transition: transform 0.2s;
        }

        /* Collapsed Options Menu */
        .mode-controls.options-collapsed {
            width: auto;
            min-width: auto;
            max-width: 50px;
            padding: 0;
            overflow: visible;
            cursor: grab;
        }

        .mode-controls.options-collapsed:active {
            cursor: grabbing;
        }

        .mode-controls.options-collapsed .options-title-bar {
            margin: 0;
            padding: 12px;
            justify-content: center;
            align-items: center;
            border-radius: 8px;
            cursor: grab;
            width: 44px;
            height: 44px;
        }

        .mode-controls.options-collapsed .options-title-bar:active {
            cursor: grabbing;
        }

        .mode-controls.options-collapsed .options-title-bar h2 {
            display: none;
        }

        .mode-controls.options-collapsed .options-collapse-icon {
            transform: rotate(0deg);
            pointer-events: none;
            font-size: 22px;
            margin: 0;
        }

        .mode-controls.options-collapsed > *:not(.options-title-bar) {
            display: none;
        }

        /* Options Menu Expand Icon Button in Top Bar */
        .options-expand-btn {
            display: none;
            width: 44px;
            height: 44px;
            background: rgba(102, 126, 234, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.2s;
            align-items: center;
            justify-content: center;
        }

        .options-expand-btn:active {
            background: rgba(102, 126, 234, 0.5);
            transform: scale(0.95);
        }

        /* Options Menu Resize Handle */
        .options-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 30px;
            height: 30px;
            cursor: nwse-resize;
            z-index: 11;
            display: flex;
            align-items: flex-end;
            justify-content: flex-end;
            padding: 5px;
        }

        .resize-grip {
            width: 0;
            height: 0;
            border-style: solid;
            border-width: 0 0 12px 12px;
            border-color: transparent transparent rgba(255, 255, 255, 0.3) transparent;
            pointer-events: none;
        }

        .options-resize-handle:hover .resize-grip {
            border-color: transparent transparent rgba(255, 255, 255, 0.5) transparent;
        }

        .options-resize-handle:active .resize-grip {
            border-color: transparent transparent rgba(102, 126, 234, 0.7) transparent;
        }

        /* Hide resize handle when collapsed */
        .mode-controls.options-collapsed .options-resize-handle {
            display: none;
        }

        .collapsible-content {
            max-height: 2000px;
            overflow: hidden;
            transition: max-height 0.3s ease-out, opacity 0.2s ease-out;
            opacity: 1;
        }

        .collapsible-content.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .mode-section {
            margin-bottom: 12px;
        }

        .mode-section:last-child {
            margin-bottom: 0;
        }

        .mode-section label {
            display: block;
            font-size: 11px;
            color: #888;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .mode-section input[type="range"] {
            touch-action: pan-x !important;
            pointer-events: auto !important;
        }

        .mode-section select {
            width: 100%;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #fff;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .mode-section select:hover {
            background: rgba(255, 255, 255, 0.08);
            border-color: #667eea;
        }

        .mode-section select:focus {
            outline: none;
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }

        .mode-section option {
            background: #1a1a1a;
            color: #fff;
        }

        .apply-btn {
            width: 100%;
            padding: 10px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 15px;
        }

        .apply-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
        }

        /* Mobile Touch Controls */
        .mobile-controls {
            display: none;
            position: fixed;
            pointer-events: none;
            z-index: 1005;
        }

        .mobile-controls.active {
            display: block;
        }

        /* Virtual Joystick Container */
        .joystick-zone {
            position: fixed;
            bottom: 100px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.4) 0%, rgba(118, 75, 162, 0.4) 100%);
            border: 3px solid rgba(102, 126, 234, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            pointer-events: auto;
        }

        .joystick-left {
            left: 50px;
        }

        .joystick-right {
            right: 20px;
        }

        .joystick-base {
            display: none;
        }

        .joystick-stick {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        /* Joystick label inside button */
        .joystick-label {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.95);
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: none;
        }

        /* Sprint button (above joystick) */
        .sprint-btn {
            position: fixed;
            bottom: 210px;
            left: 50px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(234, 102, 102, 0.4) 0%, rgba(162, 75, 75, 0.4) 100%);
            border: 3px solid rgba(234, 102, 102, 0.6);
            backdrop-filter: blur(10px);
            display: none;
            z-index: 1001;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            pointer-events: auto;
        }

        .sprint-btn.active {
            background: linear-gradient(135deg, rgba(234, 102, 102, 0.8) 0%, rgba(162, 75, 75, 0.8) 100%);
            border-color: rgba(255, 150, 150, 0.9);
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .mobile-controls.active .sprint-btn {
            display: block;
        }

        /* Sprint joystick indicator (white dot) */
        .sprint-indicator {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        /* Sprint button label inside button */
        .sprint-label {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.95);
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: none;
        }

        /* Look Joystick (above play button, right side) */
        .look-joystick-zone {
            position: fixed;
            bottom: 210px;
            right: 50px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(234, 179, 102, 0.4) 0%, rgba(162, 118, 75, 0.4) 100%);
            border: 3px solid rgba(234, 179, 102, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 1001;
            pointer-events: auto;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
        }

        .mobile-controls.active .look-joystick-zone {
            display: block;
        }

        .look-joystick-stick {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.9);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .look-joystick-label {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.95);
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: none;
        }

        /* Play/Pause button (bottom right) */
        .play-btn {
            position: fixed;
            bottom: 100px;
            right: 50px;
            width: 90px;
            height: 90px;
            border-radius: 50%;
            background: linear-gradient(135deg, rgba(102, 234, 126, 0.4) 0%, rgba(75, 162, 108, 0.4) 100%);
            border: 3px solid rgba(102, 234, 126, 0.6);
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            pointer-events: auto;
            transition: all 0.1s;
        }

        .play-btn.active {
            background: linear-gradient(135deg, rgba(102, 234, 126, 0.7) 0%, rgba(75, 162, 108, 0.7) 100%);
            border-color: rgba(102, 234, 126, 0.9);
            transform: scale(0.95);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
        }

        .mobile-controls.active .play-btn {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Play/Pause button icon */
        .play-btn-icon {
            font-size: 32px;
            color: rgba(255, 255, 255, 0.95);
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            letter-spacing: -2px;
        }

        /* Play/Pause button label inside button */
        .play-btn-label {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.95);
            font-size: 8px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            pointer-events: none;
        }

        /* Touch hint for camera control */
        .touch-hint {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 10, 0.8);
            padding: 15px 25px;
            border-radius: 8px;
            color: #667eea;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .touch-hint.show {
            opacity: 1;
        }

        /* ========================================
           NEW MOBILE UI SYSTEM
        ======================================== */

        /* Mobile Minimal Top Bar */
        /* Removed old mobile top bar and galaxy menu CSS */

        /* Options Menu 2 - LEFT SIDE */
        .mode-controls-left {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            z-index: 1000;
            min-width: 220px;
            max-width: 240px;
            max-height: calc(100vh - 240px);
            overflow-y: auto;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y;
        }

        /* Smaller screens */
        @media (max-height: 700px) {
            .galaxy-menu {
                max-height: calc(100vh - 260px);
            }
        }

        @media (max-height: 600px) {
            .galaxy-menu {
                max-height: calc(100vh - 280px);
            }
        }

        .galaxy-menu.dragging {
            transition: none;
            opacity: 0.9;
        }

        /* Galaxy Menu Scrollbar */
        .galaxy-menu::-webkit-scrollbar {
            width: 6px;
        }

        .galaxy-menu::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
        }

        .galaxy-menu::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 3px;
        }

        .galaxy-menu::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }

        /* Galaxy Menu Title Bar */
        .galaxy-title-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: -15px -15px 15px -15px;
            padding: 12px 15px;
            background: rgba(10, 10, 10, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            user-select: none;
        }

        .galaxy-title-bar h2 {
            font-size: 1.2em;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
        }

        .galaxy-collapse-icon {
            font-size: 1.2em;
            color: rgba(255, 255, 255, 0.6);
            transition: transform 0.2s;
        }

        /* Collapsed state */
        .galaxy-menu.galaxy-collapsed {
            max-height: 47px;
            overflow: hidden;
        }

        .galaxy-menu.galaxy-collapsed .galaxy-collapse-icon {
            transform: rotate(180deg);
        }

        /* Galaxy Menu h3 headers - Collapsible (same as Options Menu) */
        .galaxy-menu h3 {
            font-size: 11px;
            color: #667eea;
            margin-bottom: 6px;
            margin-top: 12px;
            padding: 4px 0;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .galaxy-menu h3:first-of-type {
            margin-top: 0;
        }

        .galaxy-menu h3:hover {
            color: #8899ff;
        }

        .galaxy-menu h3::after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.2s;
        }

        .galaxy-menu h3.collapsed::after {
            transform: rotate(-90deg);
        }

        /* Menu Overlay - DISABLED */
        .menu-overlay {
            display: none !important;
        }


        /* Quick Settings Panel */
        .quick-settings-panel {
            position: fixed;
            top: 60px;
            right: -300px;
            width: 280px;
            max-height: calc(100vh - 200px);
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            z-index: 1500;
            transition: right 0.3s ease;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .quick-settings-panel.open {
            right: 15px;
        }

        .panel-header {
            padding: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 600;
            color: #667eea;
        }

        .panel-content {
            padding: 15px;
        }

        .setting-row {
            margin-bottom: 20px;
        }

        .setting-label {
            display: block;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.6);
            margin-bottom: 8px;
        }

        .setting-value {
            font-size: 14px;
            color: #667eea;
            font-weight: 600;
        }

        /* Preset Quick Panel */
        .preset-quick-panel {
            position: fixed;
            top: 60px;
            right: -300px;
            width: 280px;
            max-height: calc(100vh - 200px);
            background: rgba(10, 10, 10, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            z-index: 1500;
            transition: right 0.3s ease;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }

        .preset-quick-panel.open {
            right: 15px;
        }

        .preset-item {
            padding: 12px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s;
            color: rgba(255, 255, 255, 0.8);
        }

        .preset-item:hover, .preset-item:active {
            background: rgba(102, 126, 234, 0.2);
            color: #fff;
        }

        /* Collapsible Player */
        .bottom-player.collapsible {
            transition: height 0.3s ease;
        }

        .bottom-player.collapsed {
            height: 50px;
            overflow: hidden;
        }

        .player-handle {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            background: rgba(20, 20, 20, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .player-handle-icon {
            color: rgba(255, 255, 255, 0.4);
            font-size: 16px;
            transition: transform 0.3s;
        }

        .bottom-player.collapsed .player-handle-icon {
            transform: rotate(180deg);
        }

        .player-mini-info {
            position: absolute;
            left: 60px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            max-width: calc(100% - 150px);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .player-mini-controls {
            position: absolute;
            right: 15px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            gap: 10px;
        }

        /* Adjust UI for mobile - prevent overlap */
        @media (max-width: 768px), (pointer: coarse) {
            .stats-overlay {
                top: 70px;
                left: 10px;
                font-size: 11px;
                min-width: 160px;
                padding: 10px 15px;
            }

            .controls-hint {
                display: none !important; /* Hide keyboard controls on mobile */
            }

            /* Collapse tag legend by default on mobile */
            .tag-legend {
                top: 160px;
                left: 10px;
                max-width: 200px;
                font-size: 10px;
                max-height: 50px;
                overflow: hidden;
            }

            .tag-legend #tagLegendContent,
            .tag-legend .search-container,
            .tag-legend > div[style*="display: flex"] {
                display: none !important;
            }

            /* Collapse tag filter panel by default on mobile */
            .tag-filter-panel {
                top: 160px;
                left: 10px;
                max-width: 200px;
            }

            /* Collapse mode controls by default on mobile */
            .mode-controls {
                top: 70px;
                bottom: auto;
                right: 10px;
                max-width: 200px;
                font-size: 10px;
                max-height: calc(100vh - 250px);
            }

            .mode-controls h3 {
                cursor: pointer;
            }

            .top-bar {
                padding: 10px 15px;
                flex-wrap: wrap;
            }

            .top-bar h1 {
                font-size: 1.1em;
            }

            .btn {
                padding: 6px 12px;
                font-size: 11px;
            }

            .bottom-player {
                height: 90px;
                font-size: 11px;
                padding: 8px 15px;
            }

            .stem-player-bar {
                height: 90px;
                padding: 8px 15px;
            }

            .multi-stem-player {
                bottom: 90px;
            }

            .multi-stem-player.collapsed {
                transform: translateY(calc(100% + 90px));
            }

            body.multi-stem-active .mode-controls,
            body.multi-stem-active .mode-controls-left {
                bottom: calc(90px + var(--multi-stem-height, 0px));
            }

            /* Ensure joysticks don't overlap with player */
            .joystick-zone {
                bottom: 110px;
            }
        }

        /* Make crosshair more visible on mobile */
        @media (pointer: coarse) {
            .crosshair {
                width: 30px;
                height: 30px;
            }
            .crosshair::before,
            .crosshair::after {
                background: rgba(255, 255, 255, 0.8);
            }
        }

        /* Info Window */
        .info-window {
            position: fixed;
            top: 120px;
            left: 20px;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0;
            z-index: 1050;
            font-size: 12px;
            line-height: 1.6;
            min-width: 250px;
            max-width: 350px;
            display: none;
            overflow: hidden;
            max-height: calc(100vh - 380px);
            cursor: grab;
        }

        .info-window:active {
            cursor: grabbing;
        }

        .info-window.visible {
            display: block;
        }

        .info-window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 15px 8px 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: grab;
            user-select: none;
        }

        .info-window-header:active {
            cursor: grabbing;
        }

        .info-window h4 {
            margin: 0;
            font-size: 13px;
            color: #667eea;
            font-weight: 600;
        }

        .info-window-close {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            font-size: 24px;
            line-height: 1;
            cursor: pointer;
            padding: 0;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .info-window-close:hover {
            background: rgba(255, 255, 255, 0.1);
            color: rgba(255, 255, 255, 0.9);
        }

        .info-window > .info-row,
        .info-window > .info-section {
            padding: 0 15px;
        }

        .info-window > .info-row:last-child,
        .info-window > .info-section:last-child {
            padding-bottom: 15px;
        }

        .info-window > .info-row:first-of-type {
            padding-top: 15px;
        }

        .info-window .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
            gap: 10px;
        }

        .info-window .info-label {
            color: rgba(255, 255, 255, 0.6);
            flex-shrink: 0;
        }

        .info-window .info-value {
            color: rgba(255, 255, 255, 0.9);
            text-align: right;
            word-break: break-word;
        }

        .info-window .info-section {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        @media (max-width: 768px) {
            .info-window {
                font-size: 11px;
                min-width: 200px;
                max-width: 250px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading your audio galaxy...</div>
    </div>

    <!-- Crosshair -->
    <div class="crosshair"></div>

    <!-- Info Window -->
    <div class="info-window" id="infoWindow">
        <div class="info-window-header">
            <h4>Galaxy Info</h4>
            <button class="info-window-close" onclick="toggleInfoWindow()">×</button>
        </div>
        <div class="info-row">
            <span class="info-label">Files:</span>
            <span class="info-value" id="infoFileCount">0</span>
        </div>
        <div class="info-row">
            <span class="info-label">Position:</span>
            <span class="info-value" id="infoCameraPos">0, 0, 0</span>
        </div>
        <div class="info-section" id="infoTargetSection" style="display: none;">
            <div class="info-row">
                <span class="info-label">Targeted:</span>
                <span class="info-value" id="infoTargetFile">None</span>
            </div>
            <div class="info-row" id="infoTargetBPMRow" style="display: none;">
                <span class="info-label">BPM:</span>
                <span class="info-value" id="infoTargetBPM">-</span>
            </div>
            <div class="info-row" id="infoTargetKeyRow" style="display: none;">
                <span class="info-label">Key:</span>
                <span class="info-value" id="infoTargetKey">-</span>
            </div>
            <div class="info-row" id="infoTargetTagsRow" style="display: none;">
                <span class="info-label">Tags:</span>
                <span class="info-value" id="infoTargetTags">-</span>
            </div>
        </div>
    </div>

    <!-- Top Bar -->
    <div class="top-bar">
        <h1>🌌 Audio Galaxy Explorer V23</h1>
        <div class="db-dropdown" id="dbDropdown">
            <button class="db-dropdown-btn" onclick="toggleDbDropdown()">
                <span>📂</span>
                <span id="dbDropdownLabel">Audio Files</span>
                <span>▼</span>
            </button>
            <div class="db-dropdown-content">
                <div class="db-dropdown-item" onclick="toggleDbSource('audioFiles', event)">
                    <input type="checkbox" id="sourceAudioFiles" checked>
                    <label>Audio Files</label>
                </div>
                <div class="db-dropdown-item" onclick="toggleDbSource('stems', event)">
                    <input type="checkbox" id="sourceAudioStems">
                    <label>Stems</label>
                </div>
            </div>
        </div>
        <div class="top-bar-actions">
            <button class="btn" onclick="resetCamera()">Reset Position</button>
            <button class="btn" onclick="toggleHideAll()">Hide All (H)</button>
            <button class="btn" onclick="toggleControlsHint()">Controls (T)</button>
            <button class="btn" onclick="toggleTopBar()">Menu (M)</button>
            <button class="btn" onclick="toggleBottomPlayer()">Player (P)</button>
            <button class="btn" onclick="toggleColorLegend()">Colors (C)</button>
            <button class="btn" onclick="toggleTagFilterPanel()">Library (Y)</button>
            <button class="btn" id="tooltipToggleBtn" onclick="toggleTooltips()">Tooltips: ON</button>
            <button class="btn" id="crosshairToggleBtn" onclick="toggleCrosshair()">Crosshair: ON</button>
            <button class="btn" onclick="toggleKeyCommandsLegend()">Keys (?)</button>
        </div>
    </div>

    <!-- Menu Overlay (lower z-index so panels are clickable) -->
    <div class="menu-overlay" id="menuOverlay" onclick="closeAllPanels()"></div>

    <!-- Options 2 (LEFT SIDE) - EXACT DUPLICATE OF OPTIONS MENU -->
    <div class="mode-controls mode-controls-left" id="optionsMenu2">
        <!-- Options Title Bar -->
        <div class="options-title-bar" onclick="toggleOptionsMenu2()">
            <h2>Options</h2>
            <span class="options-collapse-icon" id="optionsCollapseIcon2">−</span>
        </div>

        <!-- Toggle Controls Section -->
        <h3 onclick="toggleSection(this)" class="collapsed">Toggle Controls</h3>
        <div class="collapsible-content collapsed">
            <div class="mode-section">
                <button class="btn" onclick="toggleCrosshair()" style="width: 100%; margin-bottom: 10px;" id="galaxyCrosshairToggle">
                    Crosshair: ON
                </button>
            </div>

            <div class="mode-section">
                <button class="btn" onclick="toggleTooltips()" style="width: 100%; margin-bottom: 10px;" id="galaxyTooltipToggle">
                    Tooltips: ON
                </button>
            </div>

            <div class="mode-section">
                <button class="btn" onclick="toggleInfoWindow()" style="width: 100%; margin-bottom: 10px;" id="galaxyInfoToggle">
                    Info Window: OFF
                </button>
            </div>

            <div class="mode-section">
                <button class="btn" onclick="toggleFullscreen()" style="width: 100%; margin-bottom: 10px;">
                    Toggle Fullscreen
                </button>
            </div>

            <div class="mode-section">
                <button class="btn" onclick="toggleMoveJoystick()" style="width: 100%; margin-bottom: 10px;" id="galaxyMoveJoystickToggle">
                    Move Joystick: ON
                </button>
            </div>

            <div class="mode-section">
                <button class="btn" onclick="toggleLookJoystick()" style="width: 100%; margin-bottom: 10px;" id="galaxyLookJoystickToggle">
                    Look Joystick: ON
                </button>
            </div>

            <div class="mode-section">
                <button class="btn" onclick="togglePlayButton()" style="width: 100%;" id="galaxyPlayButtonToggle">
                    Play Button: ON
                </button>
            </div>
        </div>

        <!-- File Browser Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">File Browser</h3>
        <div class="collapsible-content collapsed">

            <!-- Search Bar -->
            <div class="search-container">
                <input type="text"
                       id="galaxySearchInput"
                       class="search-input"
                       placeholder="Search files..."
                       oninput="handleSearch(this.value)"
                       onkeydown="handleSearchKeyboard(event)">
                <span class="search-icon">🔍</span>
            </div>

            <!-- Database Selector -->
            <div class="mode-section" style="margin-bottom: 15px;">
                <label>Data Sources:</label>
                <div style="margin-top: 8px;">
                    <div style="display: flex; align-items: center; padding: 6px; background: rgba(255,255,255,0.05); border-radius: 4px; margin-bottom: 4px; cursor: pointer;" onclick="toggleGalaxyDbSource('audioFiles', event)">
                        <input type="checkbox" id="galaxySourceAudioFiles" checked style="margin-right: 8px; cursor: pointer;" onclick="toggleGalaxyDbSource('audioFiles', event)">
                        <label style="cursor: pointer; user-select: none;">Audio Files</label>
                    </div>
                    <div style="display: flex; align-items: center; padding: 6px; background: rgba(255,255,255,0.05); border-radius: 4px; cursor: pointer;" onclick="toggleGalaxyDbSource('stems', event)">
                        <input type="checkbox" id="galaxySourceAudioStems" style="margin-right: 8px; cursor: pointer;" onclick="toggleGalaxyDbSource('stems', event)">
                        <label style="cursor: pointer; user-select: none;">Stems</label>
                    </div>
                </div>
            </div>

            <!-- Category Filter Buttons -->
            <div style="display: flex; gap: 8px; margin-bottom: 15px;">
                <button onclick="showAllCategories()" style="flex: 1; padding: 8px; background: rgba(102,126,234,0.3); border: 1px solid #667eea; border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px;">Show All</button>
                <button onclick="hideAllCategories()" style="flex: 1; padding: 8px; background: rgba(234,102,102,0.3); border: 1px solid #ea6767; border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px;">Hide All</button>
            </div>

            <!-- File Count -->
            <div style="color: rgba(255,255,255,0.6); font-size: 11px; margin-bottom: 10px;">
                <span id="galaxyFileCount">0 files loaded</span>
            </div>

            <!-- Color Categories Legend -->
            <h4 style="color: #667eea; font-size: 11px; margin-bottom: 8px;">Colors</h4>
            <div style="max-height: 150px; overflow-y: auto; -webkit-overflow-scrolling: touch; margin-bottom: 15px;">
                <div id="galaxyTagLegend"></div>
            </div>

            <!-- Tags Section -->
            <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px; margin-bottom: 15px;">
                <h4 style="color: #667eea; font-size: 11px; margin-bottom: 8px;">Tags</h4>
                <div id="galaxyTagsList" style="max-height: 100px; overflow-y: auto; -webkit-overflow-scrolling: touch;">
                    <!-- Tags will be populated here -->
                </div>
            </div>

            <!-- File List (scrollable) -->
            <div style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 10px;">
                <h4 style="color: #667eea; font-size: 11px; margin-bottom: 8px;">Files</h4>
                <div id="galaxyFileList" style="max-height: 200px; overflow-y: auto; -webkit-overflow-scrolling: touch;">
                    <!-- File list will be populated here -->
                </div>
            </div>
        </div>

        <!-- Movement & Camera Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">Movement & Camera</h3>
        <div class="collapsible-content collapsed">

            <!-- Stem Offset Distance -->
            <div class="mode-section">
                <label>Stem Galaxy Offset: <span id="stemOffsetValue">0</span></label>
                <input type="range" min="0" max="1000" step="10" value="0"
                       oninput="updateStemOffset(this.value)"
                       style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
                <div style="font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 4px;">Distance between Audio Files and Stems galaxies (0 = same location)</div>
            </div>

            <!-- Movement Settings -->
            <div class="mode-section">
                <label>Movement Speed: <span id="galaxyMoveSpeedValue">3.0</span></label>
                <input type="range" min="0.1" max="5" step="0.1" value="3.0"
                       oninput="moveSpeed = parseFloat(this.value); document.getElementById('galaxyMoveSpeedValue').textContent = this.value;"
                       style="width: 100%;">
            </div>

            <div class="mode-section">
                <label>Look Sensitivity: <span id="galaxyLookSensValue">0.002</span></label>
                <input type="range" min="0.0005" max="0.05" step="0.0005" value="0.002"
                       oninput="lookSensitivity = parseFloat(this.value); document.getElementById('galaxyLookSensValue').textContent = this.value;"
                       style="width: 100%;">
            </div>
        </div>

        <!-- Visualization Modes Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">Visualization Modes</h3>
        <div class="collapsible-content collapsed">
            <div class="mode-section">
                <label>Color By:</label>
                <select id="galaxyColorMode" onchange="currentColorMode = this.value; recreateParticles();">
                    <option value="tags">Tags (Category)</option>
                    <option value="key">Musical Key</option>
                    <option value="bpm">BPM Range</option>
                    <option value="length">Length (Duration)</option>
                </select>
            </div>
            <div class="mode-section">
                <label>X-Axis (Left/Right):</label>
                <select id="galaxyXAxisMode" onchange="currentXMode = this.value; recreateParticles();">
                    <option value="bpm">BPM</option>
                    <option value="key">Musical Key</option>
                    <option value="tags">Tags (Hash)</option>
                    <option value="length">Length (Duration)</option>
                    <option value="random">Random</option>
                </select>
            </div>
            <div class="mode-section">
                <label>Y-Axis (Up/Down):</label>
                <select id="galaxyYAxisMode" onchange="currentYMode = this.value; recreateParticles();">
                    <option value="key">Musical Key</option>
                    <option value="bpm">BPM</option>
                    <option value="tags">Tags (Hash)</option>
                    <option value="length">Length (Duration)</option>
                    <option value="random">Random</option>
                </select>
            </div>
            <div class="mode-section">
                <label>Z-Axis (Depth):</label>
                <select id="galaxyZAxisMode" onchange="currentZMode = this.value; recreateParticles();">
                    <option value="tags">Tags (Hash)</option>
                    <option value="bpm">BPM</option>
                    <option value="key">Musical Key</option>
                    <option value="length">Length (Duration)</option>
                    <option value="random">Random</option>
                </select>
            </div>
            <div class="mode-section">
                <label>Particle Size: <span id="galaxyParticleSizeValue">5</span></label>
                <input type="range" min="1" max="10" step="0.1" value="5"
                       oninput="particleSize = parseFloat(this.value); document.getElementById('galaxyParticleSizeValue').textContent = this.value; recreateParticles();"
                       style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            </div>
            <div class="mode-section">
                <label>Brightness: <span id="galaxyBrightnessValue">0.8</span></label>
                <input type="range" min="0.5" max="10" step="0.1" value="0.8"
                       oninput="particleBrightness = parseFloat(this.value); document.getElementById('galaxyBrightnessValue').textContent = this.value; updateBrightness();"
                       style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            </div>
            <div class="mode-section">
                <label>Visibility Distance: <span id="galaxyVisibilityValue">900</span></label>
                <input type="range" min="100" max="2000" step="50" value="900"
                       oninput="visibilityDistance = parseInt(this.value); document.getElementById('galaxyVisibilityValue').textContent = this.value;"
                       style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            </div>
        </div>

        <!-- Galaxy Dynamics Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">Galaxy Dynamics</h3>
        <div class="collapsible-content collapsed">

        <div class="mode-section">
            <label>Rotation Mode:</label>
            <select id="rotationMode" onchange="updateRotationMode(this.value)">
                <option value="collective">Collective (Sphere)</option>
                <option value="spiral">Spiral Galaxy</option>
                <option value="individual">Individual Orbits</option>
            </select>
        </div>

        <div class="mode-section">
            <label>Rotation Axis:</label>
            <select id="rotationAxis" onchange="updateRotationAxis(this.value)">
                <option value="y">Y-Axis (Vertical)</option>
                <option value="x">X-Axis (Horizontal)</option>
                <option value="z">Z-Axis (Depth)</option>
                <option value="all">All Axes</option>
            </select>
        </div>

        <div class="mode-section">
            <label>Speed: <span id="speedValue">0.010</span></label>
            <input type="range" id="speedSlider" min="0" max="0.00003" step="0.0000001" value="0.0000015"
                   oninput="updateMotionSpeed(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            <input type="number" id="speedInput" min="0" max="0.00003" step="0.0000001" value="0.0000015"
                   oninput="updateMotionSpeedDirect(this.value)"
                   style="width: 100%; margin-top: 5px; padding: 4px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 11px;">
        </div>

        <div class="mode-section">
            <label>Amplitude: <span id="radiusValue">20</span></label>
            <input type="range" id="radiusSlider" min="0" max="100" step="1" value="80"
                   oninput="updateMotionRadius(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Particle Size: <span id="sizeValue">10</span></label>
            <input type="range" id="sizeSlider" min="0.5" max="100" step="0.5" value="17.5"
                   oninput="updateParticleSize(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Particle Brightness: <span id="brightnessValue">1.5</span></label>
            <input type="range" id="brightnessSlider" min="0.1" max="10.0" step="0.1" value="0.8"
                   oninput="updateParticleBrightness(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Visibility Distance: <span id="visibilityValue">500</span></label>
            <input type="range" id="visibilitySlider" min="100" max="2000" step="50" value="900"
                   oninput="updateVisibility(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Particle Shape:</label>
            <select onchange="updateParticleShape(this.value)"
                    style="width: 100%; padding: 4px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 11px;">
                <option value="circle">Circle</option>
                <option value="square">Square</option>
                <option value="disc">Disc</option>
                <option value="ring">Ring</option>
            </select>
        </div>

        <div class="mode-section">
            <label>X-Axis Scale: <span id="xAxisScaleValue">1.0</span></label>
            <input type="range" id="xAxisScaleSlider" min="0.1" max="3.0" step="0.1" value="1.0"
                   oninput="updateXAxisScale(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Y-Axis Scale: <span id="yAxisScaleValue">1.0</span></label>
            <input type="range" id="yAxisScaleSlider" min="0.1" max="3.0" step="0.1" value="1.0"
                   oninput="updateYAxisScale(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Z-Axis Scale: <span id="zAxisScaleValue">1.0</span></label>
            <input type="range" id="zAxisScaleSlider" min="0.1" max="3.0" step="0.1" value="1.0"
                   oninput="updateZAxisScale(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <button class="toggle-btn" id="motionToggle" onclick="toggleMotion()" style="width: 100%; padding: 8px; background: rgba(102,126,234,0.3); border: 1px solid #667eea; border-radius: 4px; color: #667eea; cursor: pointer;">
                Motion: ON
            </button>
        </div>
        </div>

        <!-- Sub-Particle Dynamics Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">Sub-Particle Dynamics</h3>
        <div class="collapsible-content collapsed">

        <div class="mode-section">
            <label>Cluster Spread: <span id="clusterSpreadValue">2.0</span></label>
            <input type="range" id="clusterSpreadSlider" min="0.1" max="20" step="0.1" value="10.0"
                   oninput="updateClusterSpread(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Sub-Particle Size: <span id="subParticleSizeValue">0.3</span></label>
            <input type="range" id="subParticleSizeSlider" min="0.05" max="1.0" step="0.05" value="0.3"
                   oninput="updateSubParticleSize(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Main/Sub Size Ratio: <span id="mainToSubRatioValue">2.0</span></label>
            <input type="range" id="mainToSubRatioSlider" min="1.0" max="10.0" step="0.5" value="2.0"
                   oninput="updateMainToSubRatio(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Sub-Particle Count: <span id="subParticleCountValue">15</span></label>
            <input type="range" id="subParticleCountSlider" min="3" max="50" step="1" value="48"
                   oninput="updateSubParticleCount(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Sub-Particle Distance: <span id="subParticleMotionValue">1.0</span></label>
            <input type="range" id="subParticleMotionSlider" min="0" max="50" step="0.5" value="3.6"
                   oninput="updateSubParticleMotion(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Sub-Particle Speed: <span id="subParticleSpeedValue">0.5</span></label>
            <input type="range" id="subParticleSpeedSlider" min="0.1" max="25.0" step="0.5" value="0.5"
                   oninput="updateSubParticleSpeed(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Motion Path:</label>
            <select id="motionPathSelect" onchange="updateMotionPath(this.value)"
                    style="width: 100%; padding: 4px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 11px;">
                <option value="natural">Natural (Simple Orbit)</option>
                <option value="ring">Ring (2D Orbit)</option>
                <option value="sphere">Sphere (3D Orbit)</option>
                <option value="figure8">Figure Eight</option>
                <option value="random">Random (Chaotic Orbits)</option>
                <option value="static">Static (No Motion)</option>
            </select>
        </div>

        <div class="mode-section">
            <label>Cluster Shape:</label>
            <select id="subParticleShapeSelect" onchange="updateSubParticleShape(this.value)"
                    style="width: 100%; padding: 4px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 11px;">
                <option value="default">Default</option>
                <option value="sphere">Sphere</option>
                <option value="spiked">Spiked</option>
            </select>
        </div>
        </div>

        <!-- Visual Gradients Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">Visual Gradients</h3>
        <div class="collapsible-content collapsed">
        <div class="mode-section">
            <label>Size Gradient: <span id="sizeGradientValue">0.0</span></label>
            <input type="range" id="sizeGradientSlider" min="0" max="2" step="0.1" value="0"
                   oninput="updateSizeGradient(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            <div style="font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 4px;">0 = uniform, 2 = extreme gradient (large center, tiny outer)</div>
        </div>

        <div class="mode-section">
            <label>Density Gradient: <span id="densityGradientValue">0.0</span></label>
            <input type="range" id="densityGradientSlider" min="0" max="1" step="0.1" value="0"
                   oninput="updateDensityGradient(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            <div style="font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 4px;">0 = uniform, 1 = dense center, sparse outer</div>
        </div>

        <div class="mode-section">
            <label>Bloom/Glow: <span id="bloomStrengthValue">0.0</span></label>
            <input type="range" id="bloomStrengthSlider" min="0" max="10" step="0.5" value="0"
                   oninput="updateBloomStrength(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            <div style="font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 4px;">0 = no glow, 10 = maximum bloom effect</div>
        </div>
        </div>

        <!-- Audio Reactivity Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">Audio Reactivity</h3>
        <div class="collapsible-content collapsed">
        <div class="mode-section">
            <label>Current Amplitude: <span id="audioAmplitudeDisplay" style="color: #667eea;">0.00</span></label>
        </div>

        <div class="mode-section" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; font-size: 11px;">
            <div style="text-align: center;">
                <div style="color: rgba(255,255,255,0.5);">Bass</div>
                <div id="bassAmplitudeDisplay" style="color: #f87171;">0.00</div>
            </div>
            <div style="text-align: center;">
                <div style="color: rgba(255,255,255,0.5);">Mids</div>
                <div id="midsAmplitudeDisplay" style="color: #fbbf24;">0.00</div>
            </div>
            <div style="text-align: center;">
                <div style="color: rgba(255,255,255,0.5);">Highs</div>
                <div id="highsAmplitudeDisplay" style="color: #60a5fa;">0.00</div>
            </div>
        </div>

        <div class="mode-section">
            <label>Frequency Range:</label>
            <select id="frequencyModeSelect" onchange="updateFrequencyMode(this.value)"
                    style="width: 100%; padding: 4px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 11px;">
                <option value="all">All Frequencies</option>
                <option value="bass">Bass (20-250 Hz)</option>
                <option value="mids">Mids (250-2000 Hz)</option>
                <option value="highs">Highs (2000+ Hz)</option>
            </select>
        </div>

        <div class="mode-section">
            <label>Pulse Strength (Playing): <span id="audioStrengthValue">3.0</span></label>
            <input type="range" id="audioStrengthSlider" min="0" max="100" step="1" value="40"
                   oninput="updateAudioStrength(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <label>Global Reactivity (All): <span id="globalReactivityValue">0.5</span></label>
            <input type="range" id="globalReactivitySlider" min="0" max="10" step="0.1" value="4.4"
                   oninput="updateGlobalReactivity(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
        </div>

        <div class="mode-section">
            <button class="toggle-btn" id="audioReactivityToggle" onclick="toggleAudioReactivity()" style="width: 100%; padding: 8px; background: rgba(102,126,234,0.3); border: 1px solid #667eea; border-radius: 4px; color: #667eea; cursor: pointer;">
                Audio Reactivity: ON
            </button>
        </div>
        </div>

        <!-- Crosshair Hover Effects Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">Crosshair Hover Effects</h3>
        <div class="collapsible-content collapsed">
        <div class="mode-section">
            <label>Hover Speed: <span id="hoverSpeedValue">10</span>%</label>
            <input type="range" id="hoverSpeedSlider" min="0" max="100" step="5" value="10"
                   oninput="updateHoverSpeed(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            <div style="font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 4px;">Speed % when hovered (10% = very slow)</div>
        </div>

        <div class="mode-section">
            <label>Hover Scale: <span id="hoverScaleValue">1.0</span>x</label>
            <input type="range" id="hoverScaleSlider" min="1" max="5" step="0.1" value="1.0"
                   oninput="updateHoverScale(this.value)"
                   style="width: 100%; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer;">
            <div style="font-size: 10px; color: rgba(255,255,255,0.5); margin-top: 4px;">Size multiplier when hovered (1.0 = no change)</div>
        </div>

        <div class="mode-section">
            <button class="toggle-btn" id="mouseInteractionToggle" onclick="toggleMouseInteraction()" style="width: 100%; padding: 8px; background: rgba(102,126,234,0.3); border: 1px solid #667eea; border-radius: 4px; color: #667eea; cursor: pointer;">
                Crosshair Hover: ON
            </button>
        </div>
        </div>

        <!-- Presets Section -->
        <h3 onclick="toggleSection(this)" class="collapsed" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">Presets</h3>
        <div class="collapsible-content collapsed">
        <div class="mode-section">
            <label>Preset Name:</label>
            <input type="text" id="presetNameInput" placeholder="My Preset"
                   onkeydown="if(event.key==='Enter'){event.preventDefault();savePreset();this.blur();}"
                   style="width: 100%; padding: 6px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 11px; margin-bottom: 8px;">
            <div style="margin-bottom: 8px;">
                <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; cursor: pointer;">
                    <input type="checkbox" id="saveCameraCheckbox" checked style="cursor: pointer;">
                    <span>Save Camera Position</span>
                </label>
            </div>
            <button onclick="savePreset()" style="width: 100%; padding: 8px; background: rgba(102,126,234,0.3); border: 1px solid #667eea; border-radius: 4px; color: #667eea; cursor: pointer; margin-bottom: 8px;">
                Save Preset
            </button>
        </div>

        <div class="mode-section">
            <label>Load Preset:</label>
            <select id="presetSelect" onchange="loadPreset(this.value)"
                    style="width: 100%; padding: 6px; background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; color: #fff; font-size: 11px; margin-bottom: 8px;">
                <option value="">-- Select Preset --</option>
            </select>
            <button onclick="deletePreset()" style="width: 100%; padding: 8px; background: rgba(255,50,50,0.3); border: 1px solid #ff3333; border-radius: 4px; color: #ff6666; cursor: pointer; margin-bottom: 8px;">
                Delete Selected Preset
            </button>
            <button onclick="setDefaultPreset()" style="width: 100%; padding: 8px; background: rgba(102,200,50,0.3); border: 1px solid #66cc33; border-radius: 4px; color: #88ee66; cursor: pointer; margin-bottom: 8px;">
                Set as Default Preset
            </button>
        </div>

        <div class="mode-section" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 12px; margin-top: 8px;">
            <label style="font-size: 10px; color: rgba(255,255,255,0.6);">Import/Export Presets:</label>
            <button onclick="exportPresetsAsJSON()" style="width: 100%; padding: 8px; background: rgba(66,153,225,0.3); border: 1px solid #4299e1; border-radius: 4px; color: #63b3ed; cursor: pointer; margin-bottom: 6px; font-size: 10px;">
                📥 Export All to JSON
            </button>
            <input type="file" id="presetImportFile" accept=".json" style="display: none;" onchange="importPresetsFromJSON(event)">
            <button onclick="document.getElementById('presetImportFile').click()" style="width: 100%; padding: 8px; background: rgba(66,153,225,0.3); border: 1px solid #4299e1; border-radius: 4px; color: #63b3ed; cursor: pointer; font-size: 10px;">
                📤 Import from JSON
            </button>
        </div>

        <div class="mode-section" style="border-top: 1px solid rgba(255,255,255,0.1); padding-top: 12px; margin-top: 8px;">
            <label style="font-size: 10px; color: rgba(255,255,255,0.6);">Cloud Sync (Supabase):</label>
            <button onclick="syncPresetsToCloud()" style="width: 100%; padding: 8px; background: rgba(102,126,234,0.3); border: 1px solid #667eea; border-radius: 4px; color: #667eea; cursor: pointer; margin-bottom: 6px; font-size: 10px;">
                ☁️ Upload Presets to Cloud
            </button>
            <button onclick="loadPresetsFromCloud()" style="width: 100%; padding: 8px; background: rgba(102,200,234,0.3); border: 1px solid #66c8ea; border-radius: 4px; color: #66c8ea; cursor: pointer; font-size: 10px;">
                ⬇️ Download Presets from Cloud
            </button>
            <div id="cloudSyncStatus" style="font-size: 9px; color: #888; margin-top: 6px; text-align: center;"></div>
        </div>
        </div>

        <!-- Resize Handle -->
        <div class="options-resize-handle" id="optionsResizeHandle">
            <div class="resize-grip"></div>
        </div>
    </div>

    <!-- Quick Settings Panel -->
    <div class="quick-settings-panel" id="quickSettingsPanel">
        <div class="panel-header">⚡ Quick Settings</div>
        <div class="panel-content" id="quickSettingsContent">
            <!-- Quick settings populated by JS -->
        </div>
    </div>

    <!-- Preset Quick Panel -->
    <div class="preset-quick-panel" id="presetQuickPanel">
        <div class="panel-header">🎨 Quick Presets</div>
        <div class="panel-content" id="presetQuickContent">
            <!-- Preset list populated by JS -->
        </div>
    </div>

    <!-- Stats Overlay -->
    <div class="stats-overlay">
        <div class="stat-row">
            <span class="stat-label">Total Files:</span>
            <span class="stat-value" id="totalFiles">0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">BPM Range:</span>
            <span class="stat-value" id="bpmRange">-</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Position:</span>
            <span class="stat-value" id="cameraPos">0, 0, 0</span>
        </div>
        <div class="stat-row">
            <span class="stat-label">Targeted:</span>
            <span class="stat-value" id="targetedFile">None</span>
        </div>
    </div>

    <!-- Controls Hint -->
    <div class="controls-hint" id="controlsHint">
        <h3>Controls</h3>
        <div><kbd>W/S</kbd> Move forward/backward (follows camera)</div>
        <div><kbd>A/D</kbd> Move left/right</div>
        <div><kbd>Mouse</kbd> Look around (any direction)</div>
        <div><kbd>Click</kbd> Play file • <kbd>Spacebar</kbd> Play/Pause</div>
        <div><kbd>ESC</kbd> Stop player • <kbd>Mouse Wheel</kbd> Move speed</div>
    </div>

    <!-- Key Commands Legend -->
    <div class="controls-hint" id="keyCommandsLegend" style="display: none; left: auto; right: 280px; top: 80px;">
        <h3>Keyboard Shortcuts</h3>
        <div><kbd>H</kbd> Hide All UI</div>
        <div><kbd>T</kbd> Controls • <kbd>M</kbd> Menu • <kbd>P</kbd> Player</div>
        <div><kbd>C</kbd> Colors/Legend • <kbd>Y</kbd> Library • <kbd>F</kbd> Find/Search</div>
        <div><kbd>L</kbd> Loop • <kbd>R</kbd> Shuffle</div>
        <div><kbd>-</kbd> Vol Down • <kbd>=</kbd> Vol Up</div>
        <div><kbd>,</kbd> Previous • <kbd>.</kbd> Next Track</div>
        <div><kbd>Space</kbd> Play/Pause • <kbd>ESC</kbd> Stop</div>
        <div><kbd>?</kbd> Toggle This Menu</div>
    </div>

    <!-- Tag Filter Panel (Library-style) -->
    <div class="tag-filter-panel collapsed" id="tagFilterPanel">
        <h3>
            <span>🏷️ Tag Filter</span>
            <button class="collapse-btn" onclick="toggleTagFilterCollapse()">▼</button>
        </h3>

        <div class="tag-filter-content">
        <div class="filter-mode-buttons">
            <button class="mode-btn can-have" id="canHaveBtn" onclick="setFilterMode('canHave')">
                CAN
            </button>
            <button class="mode-btn must-have" id="mustHaveBtn" onclick="setFilterMode('mustHave')">
                MUST
            </button>
            <button class="mode-btn exclude" id="excludeBtn" onclick="setFilterMode('exclude')">
                EXCLUDE
            </button>
        </div>

        <div class="tag-filter-search">
            <input type="text"
                   id="tagFilterSearch"
                   placeholder="Search tags..."
                   oninput="handleTagFilterSearch(this.value)">
            <span class="search-icon">🔍</span>
        </div>

        <div class="tag-buttons-container" id="tagButtonsContainer">
            <!-- Tag buttons will be rendered here -->
        </div>

        <div style="display: flex; gap: 8px; align-items: center; margin-top: 8px;">
            <div class="active-filters-display" id="activeFiltersDisplay" style="flex: 1;">
                No active filters
            </div>
            <button onclick="clearAllTagFilters()" style="padding: 4px 8px; background: rgba(234,102,102,0.3); border: 1px solid #ea6767; border-radius: 4px; color: #fff; cursor: pointer; font-size: 10px; white-space: nowrap;">Clear All</button>
        </div>
        </div>
    </div>

    <!-- Tag Color Legend -->
    <div class="tag-legend" id="tagLegend">
        <h3>
            <span>Color Legend</span>
            <button class="collapse-btn" onclick="toggleColorLegendCollapse()">▲</button>
        </h3>
        <div class="search-container">
            <input type="text"
                   id="fileSearchInput"
                   class="search-input"
                   placeholder="Search files..."
                   oninput="handleSearch(this.value)"
                   onkeydown="handleSearchKeyboard(event)">
            <span class="search-icon">🔍</span>
        </div>
        <div style="display: flex; gap: 8px; margin-bottom: 8px;">
            <button onclick="showAllCategories()" style="flex: 1; padding: 6px; background: rgba(102,126,234,0.3); border: 1px solid #667eea; border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px;">Select All</button>
            <button onclick="hideAllCategories()" style="flex: 1; padding: 6px; background: rgba(234,102,102,0.3); border: 1px solid #ea6767; border-radius: 4px; color: #fff; cursor: pointer; font-size: 11px;">Deselect All</button>
        </div>
        <div id="tagLegendContent"></div>
    </div>


    <!-- File Tooltip -->
    <div class="file-tooltip" id="fileTooltip">
        <div class="tooltip-close-btn" id="tooltipCloseBtn" onclick="toggleTooltips()">×</div>
        <div class="tooltip-title" id="tooltipTitle"></div>
        <div class="tooltip-metadata" id="tooltipMetadata"></div>
        <div class="tooltip-tags" id="tooltipTags"></div>
    </div>

    <!-- Bottom Audio Player -->
    <div class="bottom-player active" id="bottomPlayer">
        <div class="player-controls">
            <button class="player-btn" id="prevBtn" onclick="playPreviousOrRestart()" title="Previous (,)">
                <span>◀◀</span>
            </button>
            <button class="player-btn play-pause" id="playPauseBtn" onclick="playPause()" title="Play/Pause (Space)">
                <span id="playPauseIcon">▶</span>
            </button>
            <button class="player-btn" id="nextBtn" onclick="playNextTrack()" title="Next (.)">
                <span>▶▶</span>
            </button>
            <button class="player-btn" id="navModeBtn" onclick="toggleNavMode()" title="Toggle navigation mode: ALL or COLOR only">
                <span id="navModeText">ALL</span>
            </button>
            <button class="player-btn" id="loopBtn" onclick="toggleLoop()" title="Loop (L)">
                <span>LOOP</span>
            </button>
            <button class="player-btn" id="shuffleBtn" onclick="toggleShuffle()" title="Shuffle (R)">
                <span>SHFL</span>
            </button>
            <button class="player-btn" id="stemExpandBtn" onclick="toggleStemExpand()" title="Expand/Collapse Stems" style="display: none; background: rgba(102,126,234,0.3); border: 1px solid #667eea;">
                <span id="stemExpandIcon" style="font-size: 14px;">▼ STEMS</span>
            </button>
        </div>

        <div class="player-waveform" id="waveform"></div>

        <div class="player-info">
            <div class="player-filename" id="playerFilename">No file selected</div>
            <div class="player-metadata" id="playerMetadata"></div>
            <div class="player-time" id="playerTime">0:00 / 0:00</div>
        </div>

        <div style="display: flex; align-items: center; gap: 10px; min-width: 150px;">
            <span style="color: #999; font-size: 12px;">🔊</span>
            <input type="range" id="volumeSlider" min="0" max="100" value="100"
                   style="flex: 1; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; outline: none; cursor: pointer; touch-action: pan-x !important; pointer-events: auto !important;"
                   oninput="setVolume(this.value)">
            <span id="volumePercent" style="color: #999; font-size: 11px; min-width: 40px;">100%</span>
        </div>
    </div>

    <!-- Multi-Stem Player (initially hidden) -->
    <div class="multi-stem-player" id="multiStemPlayer" style="display: none;">
        <!-- Individual stem player bars will be added here dynamically -->
    </div>

    <!-- Mobile Touch Controls -->
    <div class="mobile-controls" id="mobileControls">
        <!-- Movement Joystick (Left) -->
        <div class="joystick-zone joystick-left" id="joystickZone">
            <div class="joystick-base"></div>
            <div class="joystick-stick" id="joystickStick"></div>
        </div>

        <!-- Look Joystick (Right, above play button) -->
        <div class="look-joystick-zone" id="lookJoystickZone">
            <div class="look-joystick-stick" id="lookJoystickStick"></div>
            <div class="look-joystick-label">LOOK</div>
        </div>

        <!-- Play/Pause Button (Bottom Right) -->
        <div class="play-btn" id="playBtn">
            <div class="play-btn-icon" id="playBtnIcon">▶</div>
        </div>
    </div>

    <!-- Touch Hint -->
    <div class="touch-hint" id="touchHint">Left: Move • Right: Look • Green: Play/Pause</div>

    <!-- Canvas Container -->
    <div id="canvas-container"></div>

    <script>
        // Initialize Supabase client
        const SUPABASE_URL = 'https://ekpsbioieoxhdjdqwohy.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVrcHNiaW9pZW94aGRqZHF3b2h5Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk2OTc4NTUsImV4cCI6MjA3NTI3Mzg1NX0.a9yg9v5R0HSj2EWBeUuAhrqBcB0P297IIPZcN6Zmffg';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Global variables
        let scene, camera, renderer, particleSystem, particles = [];
        let composer, bloomPass;
        let audioFiles = [];
        let raycaster, mouse;
        let wavesurfer = null;              // Single wavesurfer for regular files
        let stemWavesurfers = [];           // Array of wavesurfers for multi-stem playback
        let currentPlayingStems = [];       // Array of stem files currently playing
        let currentFileId = null;
        let stemGalaxyOffset = 0;           // Distance between Audio Files and Stems galaxies (configurable)
        let isLooping = false;
        let isShuffling = false;
        let isMultiStemMode = false;        // Track if we're in multi-stem playback mode
        let isMultiStemPlayerVisible = true; // Track if user wants multi-stem player visible (T key toggle)
        let navMode = 'all'; // 'all' or 'color' - navigation mode for next/prev tracks
        let currentNavCategory = null; // Track which category we're navigating within
        let motionEnabled = true;
        let tooltipsEnabled = true;
        let crosshairEnabled = true;

        // FPS controls
        let moveSpeed = 3.0; // Default movement speed
        let lookSensitivity = 0.002; // Camera look sensitivity
        let keys = {};
        let isShiftPressed = false;
        let mouseX = 0, mouseY = 0;
        let pitch = 0, yaw = 0;
        let targetPitch = 0, targetYaw = 0;  // Smoothing targets for look joystick
        const lookSmoothingFactor = 0.15;  // Lower = smoother but slower (0.1 - 0.3 recommended)
        let velocity = new THREE.Vector3();
        let isPointerLocked = false;

        // Visualization modes
        let currentColorMode = 'tags';  // tags, key, bpm
        let currentXMode = 'bpm';        // bpm, key, tags, random
        let currentYMode = 'key';        // bpm, key, tags, random
        let currentZMode = 'tags';       // bpm, key, tags, random

        // Animation - Galaxy dynamics
        let animationTime = 0;
        let orbitSpeed = 0.0000015;    // Rotation speed
        let orbitRadius = 80;          // Movement amplitude
        let galaxyCenterX = 0;         // Galaxy rotation center
        let galaxyCenterY = 0;
        let galaxyCenterZ = 0;
        let rotationMode = 'collective'; // collective, spiral, individual
        let rotationAxis = 'y';        // x, y, z, all
        let particleSize = 17.5;
        let particleShape = 'circle';  // circle, square, disc, ring
        let particleBrightness = 0.8;  // particle opacity/glow intensity
        let visibilityDistance = 900;  // How far particles are visible

        // Mouse interaction
        let mouseInteractionEnabled = true;  // Default ON
        let hoveredCluster = null;
        let hoverSlowdown = 0.1;  // 10% speed when hovered (0.1 = 10%, 1.0 = 100% normal speed)
        let hoverScale = 1.0;  // Size multiplier when hovered (1.0 = no change, 2.0 = 2x size)
        let mouse3D = new THREE.Vector3();
        let mouseWorldPos = new THREE.Vector3();

        // Audio reactivity
        let audioContext = null;
        let analyser = null;
        let audioDataArray = null;
        let currentAudioAmplitude = 0;
        let bassAmplitude = 0;
        let midsAmplitude = 0;
        let highsAmplitude = 0;
        let audioFrequencyMode = 'all';  // 'bass', 'mids', 'highs', 'all'
        let audioReactivityEnabled = true;
        let audioReactivityStrength = 40.0;  // Multiplier for pulse effect (currently playing)
        let globalAudioReactivity = 4.4;    // How much non-playing particles react to audio (0-10 scale)

        // Particle clustering
        let particlesPerCluster = 48;      // Number of sub-particles per file
        let clusterRadius = 10;              // Base radius of cluster sphere (spread control)
        let clusterSpreadOnAudio = 3.0;     // How much clusters expand with audio
        let subParticleScale = 0.3;         // Scale multiplier for sub-particles (size/glow control)
        let mainToSubSizeRatio = 2.0;       // How much bigger main particles are vs sub-particles
        let subParticleMotionSpeed = 3.6;   // Orbital/swirl speed multiplier for sub-particles
        let subParticleShape = 'default';   // default, sphere, spiked
        let subParticleMotionPath = 'natural'; // natural, ring, sphere, figure8, static
        let subParticleAnimationSpeed = 0.5; // Independent speed control for sub-particle animation

        // Max particle limits (0 = unlimited)
        let maxParticleCount = 0;      // Maximum total particles to render (0 = no limit)

        // Visual gradients
        let sizeGradient = 0.0;        // 0 = no gradient, 1 = full gradient (center large, outer small)
        let densityGradient = 0.0;     // 0 = uniform density, 1 = dense center, sparse outer
        let bloomStrength = 0.0;       // 0 = no bloom, 1 = maximum bloom/glow effect

        // Axis scaling for particle distribution
        let xAxisScale = 1.0;
        let yAxisScale = 1.0;
        let zAxisScale = 1.0;

        // Hidden categories for visibility toggle
        let hiddenCategories = new Set();

        // Tag-filtered file IDs (empty = show all)
        let tagFilteredFileIds = new Set();

        // Mobile touch controls
        let isMobileDevice = false;
        let joystickActive = false;
        let joystickDelta = { x: 0, y: 0 };
        let joystickIntensity = 0; // 0-1 range, how far joystick is pushed
        let touchLookStartX = 0;
        let touchLookStartY = 0;
        let touchLookId = null;
        let mobileSprintActive = false;

        // Musical key to Y position mapping
        const keyToPosition = {
            'Cmaj': 0, 'C#maj': 1, 'Dbmaj': 1, 'Dmaj': 2, 'D#maj': 3, 'Ebmaj': 3,
            'Emaj': 4, 'Fmaj': 5, 'F#maj': 6, 'Gbmaj': 6, 'Gmaj': 7, 'G#maj': 8,
            'Abmaj': 8, 'Amaj': 9, 'A#maj': 10, 'Bbmaj': 10, 'Bmaj': 11,
            'Cmin': 0.5, 'C#min': 1.5, 'Dbmin': 1.5, 'Dmin': 2.5, 'D#min': 3.5,
            'Ebmin': 3.5, 'Emin': 4.5, 'Fmin': 5.5, 'F#min': 6.5, 'Gbmin': 6.5,
            'Gmin': 7.5, 'G#min': 8.5, 'Abmin': 8.5, 'Amin': 9.5, 'A#min': 10.5,
            'Bbmin': 10.5, 'Bmin': 11.5
        };

        // Main category colors - Expanded predefined assignments
        const mainCategoryColors = {
            'drm': { hue: 0, sat: 0.8, name: 'Red' },           // Drums = Red
            'inst': { hue: 30, sat: 0.8, name: 'Orange' },      // Instruments = Orange
            'vox': { hue: 240, sat: 0.8, name: 'Blue' },        // Vocals = Blue
            'bass': { hue: 280, sat: 0.8, name: 'Purple' },     // Bass = Purple
            'gtr': { hue: 60, sat: 0.8, name: 'Yellow' },       // Guitar = Yellow
            'pno': { hue: 180, sat: 0.8, name: 'Cyan' },        // Piano = Cyan
            'piano': { hue: 180, sat: 0.8, name: 'Cyan' },      // Piano (alt) = Cyan
            'syn': { hue: 120, sat: 0.8, name: 'Green' },       // Synth = Green
            'perc': { hue: 15, sat: 0.85, name: 'Coral' },      // Percussion = Coral
            'pad': { hue: 200, sat: 0.75, name: 'Sky' },        // Pad = Sky Blue
            'lead': { hue: 320, sat: 0.8, name: 'Magenta' },    // Lead = Magenta
            'fx': { hue: 160, sat: 0.7, name: 'Teal' },         // FX = Teal
            'arp': { hue: 270, sat: 0.8, name: 'Violet' },      // Arpeggio = Violet
            'other': { hue: 0, sat: 0, name: 'Gray' }           // Other = Gray
        };

        // Auto-detected categories (populated after loading data) - UNLIMITED
        const autoDetectedCategories = new Map();

        // Color palette for auto-detected categories (cycles through if needed)
        const colorPalette = [
            { hue: 90, sat: 0.7, name: 'Lime' },
            { hue: 45, sat: 0.75, name: 'Gold' },
            { hue: 300, sat: 0.7, name: 'Pink' },
            { hue: 140, sat: 0.6, name: 'Emerald' },
            { hue: 20, sat: 0.8, name: 'Orange-Red' },
            { hue: 260, sat: 0.75, name: 'Purple-Blue' },
            { hue: 190, sat: 0.65, name: 'Aqua' },
            { hue: 350, sat: 0.7, name: 'Rose' },
            { hue: 110, sat: 0.6, name: 'Yellow-Green' },
            { hue: 220, sat: 0.7, name: 'Indigo' }
        ];

        // Function to intelligently extract category from filename or tags
        function extractCategoryFromFile(file) {
            let category = null;

            // Priority 0: If this is a stem, extract common prefix from stem name
            if (file.stem_type && file.name) {
                const name = file.name.toLowerCase();
                // Extract everything before the stem type suffix (e.g., "cut you_vocals.wav" -> "cut you")
                // Look for patterns like: "name_vocals", "name_bass", "name_drums", "name_other"
                const stemPrefixMatch = name.match(/^(.+?)[-_](vocals?|bass|drums?|other|instrument)/i);
                if (stemPrefixMatch) {
                    return stemPrefixMatch[1].trim(); // Return the song name prefix
                }
                // Fallback: try to get anything before last underscore or dash
                const lastDelimMatch = name.match(/^(.+)[-_][^-_]+$/);
                if (lastDelimMatch) {
                    return lastDelimMatch[1].trim();
                }
            }

            // Priority 1: Check filename prefix first (most consistent for grouping)
            if (file.name) {
                const name = file.name.toLowerCase();

                // Extract prefix before first delimiter (-, _, space)
                const prefixMatch = name.match(/^([a-z]+)[-_\s]/);
                if (prefixMatch) {
                    const prefix = prefixMatch[1];

                    // If it's a known main category, use it immediately
                    if (mainCategoryColors[prefix]) {
                        return prefix;
                    }

                    // Otherwise store as candidate
                    category = prefix;
                }

                // If no prefix found, check if any main category appears in filename
                if (!category) {
                    for (const mainCat in mainCategoryColors) {
                        if (mainCat !== 'other' && name.includes(mainCat)) {
                            return mainCat;
                        }
                    }
                }
            }

            // Priority 2: Check tags array as fallback
            if (!category && file.tags && file.tags.length > 0) {
                const firstTag = file.tags[0].toLowerCase().trim();
                if (firstTag) {
                    category = firstTag;
                }
            }

            // Priority 3: Use extracted prefix/category or default to 'other'
            return category || 'other';
        }

        // Minimum files needed for a category to get its own color (threshold)
        const CATEGORY_THRESHOLD = 3;

        // Store sub-categories (categories with <threshold files) for 'other' expansion
        const subCategories = new Map(); // category name -> file count
        let otherCategoryExpanded = false; // Track expansion state of 'other' category

        // Function to detect ALL categories from loaded data (unlimited)
        function detectFrequentTags() {
            const categoryCounts = new Map();

            // Count all categories from files
            audioFiles.forEach(file => {
                const category = extractCategoryFromFile(file);
                categoryCounts.set(category, (categoryCounts.get(category) || 0) + 1);
            });

            // Clear previous auto-detected categories and sub-categories
            autoDetectedCategories.clear();
            subCategories.clear();

            // Auto-assign colors to categories with >= threshold files
            let paletteIndex = 0;
            categoryCounts.forEach((count, category) => {
                // Skip main categories and 'other'
                if (mainCategoryColors[category] || category === 'other') {
                    return;
                }

                if (count >= CATEGORY_THRESHOLD) {
                    // Assign color - this category gets its own color
                    const colorData = colorPalette[paletteIndex % colorPalette.length];
                    autoDetectedCategories.set(category, colorData);
                    paletteIndex++;
                } else {
                    // Group into 'other' - store as sub-category
                    subCategories.set(category, count);
                }
            });

            console.log(`Auto-colored categories (${autoDetectedCategories.size}):`, Array.from(autoDetectedCategories.keys()));
            console.log(`Sub-categories in 'other' (${subCategories.size}):`, Array.from(subCategories.keys()));
        }

        // Function to get category for a file (for display/grouping purposes)
        function getCategoryForFile(file) {
            const rawCategory = extractCategoryFromFile(file);

            // If it's a sub-category (< threshold files), group it into 'other'
            if (subCategories.has(rawCategory)) {
                return 'other';
            }

            return rawCategory;
        }

        // Function to get the RAW category (before grouping into 'other')
        function getRawCategoryForFile(file) {
            return extractCategoryFromFile(file);
        }

        // Function to get color for a category
        function getColorForCategory(category) {
            // Check main categories first
            if (mainCategoryColors[category]) {
                return mainCategoryColors[category];
            }

            // Check auto-detected categories
            if (autoDetectedCategories.has(category)) {
                return autoDetectedCategories.get(category);
            }

            // Default to white for 'other' (changed from gray)
            if (category === 'other') {
                return { hue: 0, sat: 0, name: 'White' }; // White instead of gray
            }

            // Fallback to gray
            return mainCategoryColors['other'];
        }

        // Function to get color based on current mode
        function getColorForFile(file) {
            if (currentColorMode === 'tags') {
                const category = getCategoryForFile(file);
                return getColorForCategory(category);
            } else if (currentColorMode === 'key') {
                return getColorByKey(file.key);
            } else if (currentColorMode === 'bpm') {
                return getColorByBPM(file.bpm);
            } else if (currentColorMode === 'length') {
                return getColorByLength(file.length);
            }
            return { hue: 200, sat: 0.6 }; // Default
        }

        // Get color by musical key (circle of fifths)
        const keyColorMap = {
            'Cmaj': 0, 'Gmaj': 30, 'Dmaj': 60, 'Amaj': 90, 'Emaj': 120, 'Bmaj': 150,
            'F#maj': 180, 'Dbmaj': 210, 'Abmaj': 240, 'Ebmaj': 270, 'Bbmaj': 300, 'Fmaj': 330,
            'Cmin': 15, 'Gmin': 45, 'Dmin': 75, 'Amin': 105, 'Emin': 135, 'Bmin': 165,
            'F#min': 195, 'Dbmin': 225, 'Abmin': 255, 'Ebmin': 285, 'Bbmin': 315, 'Fmin': 345
        };

        function getColorByKey(key) {
            if (key && keyColorMap[key] !== undefined) {
                return { hue: keyColorMap[key], sat: 0.8, name: key };
            }
            return { hue: 0, sat: 0, name: 'No Key' }; // Gray for no key
        }

        // Get color by BPM range
        function getColorByBPM(bpm) {
            if (!bpm) return { hue: 0, sat: 0, name: 'No BPM' }; // Gray

            // BPM ranges with colors
            if (bpm < 80) return { hue: 240, sat: 0.8, name: '< 80 BPM' };       // Blue (slow)
            if (bpm < 100) return { hue: 180, sat: 0.8, name: '80-99 BPM' };    // Cyan
            if (bpm < 120) return { hue: 120, sat: 0.8, name: '100-119 BPM' };  // Green
            if (bpm < 140) return { hue: 60, sat: 0.8, name: '120-139 BPM' };   // Yellow
            if (bpm < 160) return { hue: 30, sat: 0.8, name: '140-159 BPM' };   // Orange
            return { hue: 0, sat: 0.8, name: '160+ BPM' };                      // Red (fast)
        }

        // Get color by length/duration (rainbow spectrum: red=short → purple=long)
        function getColorByLength(length) {
            if (!length) return { hue: 0, sat: 0, name: 'No Length' }; // Gray

            // Rainbow spectrum: Red → Orange → Yellow → Green → Cyan → Blue → Purple
            if (length < 30) return { hue: 0, sat: 0.8, name: '< 30s' };        // Red (short)
            if (length < 60) return { hue: 30, sat: 0.8, name: '30s-1min' };    // Orange
            if (length < 120) return { hue: 60, sat: 0.8, name: '1-2min' };     // Yellow
            if (length < 180) return { hue: 120, sat: 0.8, name: '2-3min' };    // Green
            if (length < 240) return { hue: 180, sat: 0.8, name: '3-4min' };    // Cyan
            if (length < 300) return { hue: 240, sat: 0.8, name: '4-5min' };    // Blue
            return { hue: 280, sat: 0.8, name: '5min+' };                       // Purple (long)
        }

        // Calculate position value for axis based on mode
        function calculateAxisValue(file, mode, range) {
            switch(mode) {
                case 'bpm':
                    if (file.bpm) {
                        const normalized = ((file.bpm - 60) / 140);
                        return normalized * range - (range / 2);
                    }
                    return (Math.random() - 0.5) * range;

                case 'key':
                    if (file.key && keyToPosition[file.key] !== undefined) {
                        const normalized = keyToPosition[file.key] / 11.5;
                        return normalized * range - (range / 2);
                    }
                    return (Math.random() - 0.5) * range;

                case 'tags':
                    if (file.tags && file.tags.length > 0) {
                        const tagHash = file.tags[0].split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                        const normalized = (tagHash % 100) / 100;
                        return normalized * range - (range / 2);
                    }
                    return (Math.random() - 0.5) * range;

                case 'length':
                    if (file.length) {
                        // Normalize length 0-300 seconds (0-5min) to position range
                        const normalized = Math.min(file.length / 300, 1);
                        return normalized * range - (range / 2);
                    }
                    return (Math.random() - 0.5) * range;

                case 'random':
                default:
                    return (Math.random() - 0.5) * range;
            }
        }

        // Initialize Three.js scene
        function initScene() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x000000, 10, visibilityDistance);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, visibilityDistance * 2);
            camera.position.set(0, 10, 30);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Setup post-processing for bloom effect
            const renderScene = new THREE.RenderPass(scene, camera);
            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                0.0,    // strength (will be controlled by slider)
                1.0,    // radius (larger = wider glow)
                0.1     // threshold (lower = bloom affects dimmer objects)
            );

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const light1 = new THREE.PointLight(0x667eea, 1.5, 100);
            light1.position.set(50, 50, 50);
            scene.add(light1);

            const light2 = new THREE.PointLight(0x764ba2, 1.5, 100);
            light2.position.set(-50, -50, -50);
            scene.add(light2);

            // Add stars background
            addStarsBackground();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('click', onClick);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            // Mouse wheel removed - was interfering with menu scrolling

            // Detect mobile FIRST before adding pointer lock
            detectMobileDevice();

            // Only add pointer lock on desktop
            if (!isMobileDevice) {
                renderer.domElement.addEventListener('click', () => {
                    renderer.domElement.requestPointerLock();
                });

                document.addEventListener('pointerlockchange', () => {
                    isPointerLocked = document.pointerLockElement === renderer.domElement;
                });
            }

            // Initialize mobile controls if needed
            if (isMobileDevice) {
                initMobileControls();
            }

            animate();
        }

        // Detect mobile device
        function detectMobileDevice() {
            isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
                || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
        }

        // ========================================
        // NEW MOBILE UI FUNCTIONS
        // ========================================

        // toggleFullMenu() is deprecated - Galaxy Menu now uses toggleGalaxyMenu()

        function toggleQuickSettings() {
            const panel = document.getElementById('quickSettingsPanel');
            const overlay = document.getElementById('menuOverlay');
            const isOpen = panel.classList.contains('open');

            if (isOpen) {
                panel.classList.remove('open');
                overlay.classList.remove('active');
            } else {
                closeAllPanels();
                panel.classList.add('open');
                overlay.classList.add('active');
                populateQuickSettings();
            }
        }

        function togglePresetQuick() {
            const panel = document.getElementById('presetQuickPanel');
            const overlay = document.getElementById('menuOverlay');
            const isOpen = panel.classList.contains('open');

            if (isOpen) {
                panel.classList.remove('open');
                overlay.classList.remove('active');
            } else {
                closeAllPanels();
                panel.classList.add('open');
                overlay.classList.add('active');
                populatePresetQuickList();
            }
        }

        function closeAllPanels() {
            // Galaxy Menu doesn't use 'open' class anymore
            document.getElementById('quickSettingsPanel').classList.remove('open');
            document.getElementById('presetQuickPanel').classList.remove('open');
            document.getElementById('menuOverlay').classList.remove('active');
        }

        // Options Menu Position Tracking
        let optionsMenuPosition = { x: 20, y: null, bottom: 310 };
        let optionsMenuDragState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            startMenuX: 0,
            startMenuY: 0,
            hasMoved: false
        };

        // Options Menu 2 Position Tracking (separate state)
        let optionsMenu2Position = { x: 20, y: 20, bottom: null };
        let optionsMenu2DragState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            startMenuX: 0,
            startMenuY: 0,
            hasMoved: false
        };


        function populateQuickSettings() {
            const content = document.getElementById('quickSettingsContent');
            content.innerHTML = `
                <div class="setting-row">
                    <label class="setting-label">Particle Size <span class="setting-value" id="qsParticleSize">${particleSize}</span></label>
                    <input type="range" min="1" max="10" step="0.1" value="${particleSize}"
                           oninput="particleSize = parseFloat(this.value); document.getElementById('qsParticleSize').textContent = this.value; recreateParticles();"
                           style="width: 100%;">
                </div>
                <div class="setting-row">
                    <label class="setting-label">Brightness <span class="setting-value" id="qsBrightness">${particleBrightness}</span></label>
                    <input type="range" min="0.5" max="10" step="0.1" value="${particleBrightness}"
                           oninput="particleBrightness = parseFloat(this.value); document.getElementById('qsBrightness').textContent = this.value; updateBrightness();"
                           style="width: 100%;">
                </div>
                <div class="setting-row">
                    <label class="setting-label">Bloom <span class="setting-value" id="qsBloom">${bloomStrength}</span></label>
                    <input type="range" min="0" max="5" step="0.1" value="${bloomStrength}"
                           oninput="bloomStrength = parseFloat(this.value); document.getElementById('qsBloom').textContent = this.value; updateBloom();"
                           style="width: 100%;">
                </div>
                <div class="setting-row">
                    <label class="setting-label">Audio Reactivity <span class="setting-value" id="qsReactivity">${clusterSpreadOnAudio}</span></label>
                    <input type="range" min="0" max="100" step="1" value="${clusterSpreadOnAudio}"
                           oninput="clusterSpreadOnAudio = parseFloat(this.value); document.getElementById('qsReactivity').textContent = this.value;"
                           style="width: 100%;">
                </div>
                <div class="setting-row">
                    <button class="btn" onclick="resetCamera()" style="width: 100%;">Reset Camera</button>
                </div>
                <div class="setting-row">
                    <button class="btn" onclick="toggleCrosshair()" style="width: 100%;">
                        Crosshair: ${crosshairEnabled ? 'ON' : 'OFF'}
                    </button>
                </div>
                <div class="setting-row">
                    <button class="btn" onclick="toggleTooltips()" style="width: 100%;">
                        Tooltips: ${tooltipsEnabled ? 'ON' : 'OFF'}
                    </button>
                </div>
            `;
        }

        function populatePresetQuickList() {
            const content = document.getElementById('presetQuickContent');
            const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
            const presetNames = Object.keys(presets);

            if (presetNames.length === 0) {
                content.innerHTML = '<p style="color: rgba(255,255,255,0.5); padding: 15px;">No presets saved</p>';
                return;
            }

            let html = '';
            presetNames.forEach((name, index) => {
                html += `
                    <div class="preset-item" onclick="loadPreset('${name}'); closeAllPanels();">
                        <div style="font-weight: 600;">${index + 1}. ${name}</div>
                    </div>
                `;
            });

            content.innerHTML = html;
        }

        // Populate Galaxy Menu with current values
        function populateGalaxyMenu() {
            // Sync visualization mode selects (with null checks)
            const galaxyColorMode = document.getElementById('galaxyColorMode');
            if (galaxyColorMode) galaxyColorMode.value = currentColorMode;

            const galaxyXAxisMode = document.getElementById('galaxyXAxisMode');
            if (galaxyXAxisMode) galaxyXAxisMode.value = currentXMode;

            const galaxyYAxisMode = document.getElementById('galaxyYAxisMode');
            if (galaxyYAxisMode) galaxyYAxisMode.value = currentYMode;

            const galaxyZAxisMode = document.getElementById('galaxyZAxisMode');
            if (galaxyZAxisMode) galaxyZAxisMode.value = currentZMode;

            // Sync particle settings (with null checks)
            const galaxyParticleSizeValue = document.getElementById('galaxyParticleSizeValue');
            if (galaxyParticleSizeValue) galaxyParticleSizeValue.textContent = particleSize;

            const galaxyBrightnessValue = document.getElementById('galaxyBrightnessValue');
            if (galaxyBrightnessValue) galaxyBrightnessValue.textContent = particleBrightness;

            const galaxyVisibilityValue = document.getElementById('galaxyVisibilityValue');
            if (galaxyVisibilityValue) galaxyVisibilityValue.textContent = visibilityDistance;

            // Sync control toggles (with null checks)
            const galaxyMotionToggle = document.getElementById('galaxyMotionToggle');
            if (galaxyMotionToggle) galaxyMotionToggle.textContent = `Motion: ${motionEnabled ? 'ON' : 'OFF'}`;

            const galaxyCrosshairToggle = document.getElementById('galaxyCrosshairToggle');
            if (galaxyCrosshairToggle) galaxyCrosshairToggle.textContent = `Crosshair: ${crosshairEnabled ? 'ON' : 'OFF'}`;

            const galaxyTooltipToggle = document.getElementById('galaxyTooltipToggle');
            if (galaxyTooltipToggle) galaxyTooltipToggle.textContent = `Tooltips: ${tooltipsEnabled ? 'ON' : 'OFF'}`;

            // Sync movement settings (with null checks)
            const galaxyMoveSpeedValue = document.getElementById('galaxyMoveSpeedValue');
            if (galaxyMoveSpeedValue) galaxyMoveSpeedValue.textContent = moveSpeed;

            const galaxyHoverSpeedValue = document.getElementById('galaxyHoverSpeedValue');
            if (galaxyHoverSpeedValue) galaxyHoverSpeedValue.textContent = hoverSlowdown * 100;

            // Populate tag legend
            populateGalaxyTagLegend();

            // Populate preset list
            populateGalaxyPresetList();

            // Update file count - show visible files in galaxy
            const galaxyFileCount = document.getElementById('galaxyFileCount');
            if (galaxyFileCount) {
                const visibleCount = searchFilteredFileIds.size > 0 ? searchFilteredFileIds.size : particles.length;
                const totalCount = audioFiles.length;
                galaxyFileCount.textContent = `${visibleCount} visible (${totalCount} total)`;
            }

            // Populate tags list
            populateGalaxyTagsList();

            // Populate file list
            populateGalaxyFileList();
        }

        function populateGalaxyTagsList() {
            const container = document.getElementById('galaxyTagsList');
            if (!container) return;

            // Get visible files based on search and filters
            let visibleFiles = [];
            if (searchFilteredFileIds.size > 0) {
                visibleFiles = audioFiles.filter(f => searchFilteredFileIds.has(f.id));
            } else {
                visibleFiles = particles.map(p => p.file);
            }

            // Collect all unique tags from visible files
            const tagCounts = new Map();
            visibleFiles.forEach(file => {
                if (file.tags && Array.isArray(file.tags)) {
                    file.tags.forEach(tag => {
                        tagCounts.set(tag, (tagCounts.get(tag) || 0) + 1);
                    });
                }
            });

            if (tagCounts.size === 0) {
                container.innerHTML = '<div style="color: rgba(255,255,255,0.4); font-size: 10px; padding: 4px;">No tags found</div>';
                return;
            }

            // Sort tags by count (descending) then alphabetically
            const sortedTags = Array.from(tagCounts.entries()).sort((a, b) => {
                if (b[1] !== a[1]) return b[1] - a[1]; // Sort by count descending
                return a[0].localeCompare(b[0]); // Then alphabetically
            });

            let html = '<div style="display: flex; flex-wrap: wrap; gap: 4px;">';
            sortedTags.forEach(([tag, count]) => {
                html += `
                    <div style="display: inline-flex; align-items: center; padding: 3px 8px; background: rgba(102,126,234,0.2); border: 1px solid rgba(102,126,234,0.4); border-radius: 12px; cursor: pointer; font-size: 9px;"
                         onclick="handleTagClick('${tag.replace(/'/g, "\\'")}');"
                         onmouseover="this.style.background='rgba(102,126,234,0.3)';"
                         onmouseout="this.style.background='rgba(102,126,234,0.2)';">
                        <span>${tag}</span>
                        <span style="margin-left: 4px; color: rgba(255,255,255,0.5);">(${count})</span>
                    </div>
                `;
            });
            html += '</div>';

            container.innerHTML = html;
        }

        function handleTagClick(tag) {
            // Set search to this tag
            const searchInputs = document.querySelectorAll('#fileSearchInput, #galaxySearchInput');
            searchInputs.forEach(input => {
                if (input) input.value = tag;
            });
            handleSearch(tag);
        }

        function populateGalaxyFileList() {
            const container = document.getElementById('galaxyFileList');
            if (!container) return;

            // Get visible files based on search and filters
            let visibleFiles = [];
            if (searchFilteredFileIds.size > 0) {
                // Search is active - show only matching files
                visibleFiles = audioFiles.filter(f => searchFilteredFileIds.has(f.id));
            } else {
                // No search - show all files from visible particles
                visibleFiles = particles.map(p => p.file);
            }

            if (visibleFiles.length === 0) {
                container.innerHTML = '<div style="color: rgba(255,255,255,0.4); font-size: 10px; padding: 8px;">No files match your search</div>';
                return;
            }

            // Sort files alphabetically
            visibleFiles.sort((a, b) => (a.name || '').localeCompare(b.name || ''));

            let html = '';
            visibleFiles.forEach((file, index) => {
                const category = getCategoryForFile(file);
                const colorData = getColorForCategory(category);
                const color = new THREE.Color().setHSL(colorData.hue / 360, colorData.sat, 0.6);
                const hexColor = '#' + color.getHexString();

                html += `
                    <div style="display: flex; align-items: center; padding: 4px 6px; margin-bottom: 2px; background: rgba(255,255,255,0.02); border-radius: 3px; cursor: pointer; font-size: 10px;"
                         onclick="loadAndPlayFile(audioFiles.find(f => f.id === '${file.id}'));"
                         onmouseover="this.style.background='rgba(102,126,234,0.2)';"
                         onmouseout="this.style.background='rgba(255,255,255,0.02)';">
                        <div style="width: 8px; height: 8px; border-radius: 50%; background: ${hexColor}; margin-right: 6px; flex-shrink: 0;"></div>
                        <div style="flex: 1; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${file.name}</div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function toggleGalaxyDbSource(source, event) {
            event.stopPropagation(); // Prevent any bubbling

            // Toggle the Galaxy Menu checkbox
            const galaxyCheckbox = document.getElementById(source === 'audioFiles' ? 'galaxySourceAudioFiles' : 'galaxySourceAudioStems');
            galaxyCheckbox.checked = !galaxyCheckbox.checked;

            // Sync with desktop checkbox
            const desktopCheckbox = document.getElementById(source === 'audioFiles' ? 'sourceAudioFiles' : 'sourceAudioStems');
            if (desktopCheckbox) {
                desktopCheckbox.checked = galaxyCheckbox.checked;
            }

            // Call the main update function
            updateDataSources();
        }

        function populateGalaxyTagLegend() {
            const container = document.getElementById('galaxyTagLegend');
            const legendContent = document.getElementById('tagLegendContent');
            if (!container || !legendContent) return;

            // Copy the legend content
            container.innerHTML = legendContent.innerHTML;

            // Add click handlers to make categories toggleable
            const items = container.querySelectorAll('.tag-legend-item');
            items.forEach(item => {
                const category = item.dataset.category;
                if (!category) return;

                const colorDot = item.querySelector('.tag-legend-color');
                const nameDiv = item.querySelector('.tag-legend-name');

                if (colorDot && nameDiv) {
                    // Create toggle function for both dot and name
                    const toggleVisibility = (e) => {
                        e.preventDefault();
                        e.stopPropagation();

                        if (hiddenCategories.has(category)) {
                            // Show category
                            hiddenCategories.delete(category);
                            colorDot.style.opacity = '1';
                            colorDot.style.filter = 'none';
                        } else {
                            // Hide category
                            hiddenCategories.add(category);
                            colorDot.style.opacity = '0.3';
                            colorDot.style.filter = 'grayscale(100%)';
                        }

                        // Update main legend too (sync visual state)
                        const mainLegendItems = document.querySelectorAll('#tagLegendContent .tag-legend-item');
                        mainLegendItems.forEach(mainItem => {
                            if (mainItem.dataset.category === category) {
                                const mainColorDot = mainItem.querySelector('.tag-legend-color');
                                if (mainColorDot) {
                                    if (hiddenCategories.has(category)) {
                                        mainColorDot.style.opacity = '0.3';
                                        mainColorDot.style.filter = 'grayscale(100%)';
                                    } else {
                                        mainColorDot.style.opacity = '1';
                                        mainColorDot.style.filter = 'none';
                                    }
                                }
                            }
                        });

                        // NO need to recreate particles - animation loop already filters by hiddenCategories
                        // Just update file count and lists
                        if (typeof populateGalaxyFileList === 'function') {
                            populateGalaxyFileList();
                        }
                        const galaxyFileCount = document.getElementById('galaxyFileCount');
                        if (galaxyFileCount) {
                            const visibleParticles = particles.filter(p => !hiddenCategories.has(getCategoryForFile(p.file)));
                            const visibleCount = searchFilteredFileIds.size > 0 ? searchFilteredFileIds.size : visibleParticles.length;
                            const totalCount = audioFiles.length;
                            galaxyFileCount.textContent = `${visibleCount} visible (${totalCount} total)`;
                        }
                    };

                    // Make both clickable - prevent text selection
                    colorDot.onclick = toggleVisibility;
                    nameDiv.onclick = toggleVisibility;
                    colorDot.style.cursor = 'pointer';
                    nameDiv.style.cursor = 'pointer';
                    nameDiv.style.userSelect = 'none';
                    nameDiv.style.webkitUserSelect = 'none';
                    nameDiv.style.webkitTouchCallout = 'none';
                    item.style.userSelect = 'none';
                    item.style.webkitUserSelect = 'none';
                }
            });
        }

        function populateGalaxyPresetList() {
            const container = document.getElementById('galaxyPresetList');
            if (!container) return; // Exit if container doesn't exist yet

            const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
            const presetNames = Object.keys(presets);

            if (presetNames.length === 0) {
                container.innerHTML = '<p style="color: rgba(255,255,255,0.5); font-size: 11px;">No presets saved yet</p>';
                return;
            }

            let html = '';
            presetNames.forEach((name, index) => {
                html += `
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; margin-bottom: 6px;">
                        <span style="font-size: 12px; cursor: pointer;" onclick="loadPreset('${name}'); closeAllPanels();">${index + 1}. ${name}</span>
                        <button onclick="deletePreset('${name}')" style="padding: 4px 8px; background: rgba(234,102,102,0.3); border: 1px solid #ea6767; border-radius: 4px; color: #fff; cursor: pointer; font-size: 10px;">Delete</button>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function savePresetFromGalaxy() {
            const nameInput = document.getElementById('galaxyPresetName');
            const name = nameInput.value.trim();

            if (!name) {
                alert('Please enter a preset name');
                return;
            }

            savePreset(name);
            nameInput.value = '';
            populateGalaxyPresetList();
        }


        function togglePlayerCollapse() {
            const player = document.querySelector('.bottom-player');
            player.classList.toggle('collapsed');
        }

        // Initialize touch controls for mobile
        function initMobileControls() {
            // Show mobile controls
            document.getElementById('mobileControls').classList.add('active');

            // Hide desktop UI
            document.querySelector('.top-bar').style.display = 'none';
            document.querySelector('.stats-overlay').style.display = 'none';
            const controlsHint = document.getElementById('controlsHint');
            if (controlsHint) controlsHint.style.display = 'none';

            // Show collapsible player handle on mobile
            const playerHandle = document.getElementById('playerHandle');
            if (playerHandle) playerHandle.style.display = 'flex';

            // Start player collapsed on mobile
            document.getElementById('bottomPlayer').classList.add('collapsed');

            // Show touch hint briefly
            const touchHint = document.getElementById('touchHint');
            touchHint.classList.add('show');
            setTimeout(() => {
                touchHint.classList.remove('show');
            }, 3000);

            // Setup joystick
            setupJoystick();

            // Setup look joystick
            setupLookJoystick();

            // Setup play/pause button
            setupPlayButton();

            // Setup swipe to look
            setupSwipeToLook();

            // Collapse panels by default on mobile
            collapsePanelsOnMobile();

            // Prevent body scrolling on mobile
            document.body.addEventListener('touchmove', (e) => {
                // Allow scrolling/interaction in specific UI elements, mobile controls, and players (including sliders)
                if (e.target.closest('.tag-legend, .mode-controls, .tag-filter-panel, .top-bar-actions, .mobile-controls, .bottom-player, .multi-stem-player')) {
                    return;
                }
                e.preventDefault();
            }, { passive: false });

            // iOS audio unlock - requires user interaction
            const unlockAudio = () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                document.removeEventListener('touchstart', unlockAudio);
            };
            document.addEventListener('touchstart', unlockAudio);

            // Initialize draggable options menu
            initOptionsMenu2Drag();

            // Initialize resizable options menu
            initOptionsMenu2Resize();

            // Initialize draggable info window
            initInfoWindowDrag();
        }

        // Virtual Joystick Setup
        function setupJoystick() {
            const joystickZone = document.getElementById('joystickZone');
            const joystickStick = document.getElementById('joystickStick');
            const maxDistance = 45; // Max distance stick can move from center

            joystickZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                joystickActive = true;
                updateJoystick(e.touches[0]);
            });

            joystickZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (joystickActive) {
                    updateJoystick(e.touches[0]);
                }
            });

            joystickZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                joystickActive = false;
                joystickDelta = { x: 0, y: 0 };
                joystickIntensity = 0;
                joystickStick.style.transform = 'translate(-50%, -50%)';
                // Clear movement keys
                keys = {};
            });

            function updateJoystick(touch) {
                const rect = joystickZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Calculate intensity (0-1 based on how far joystick is pushed)
                const linearIntensity = Math.min(distance / maxDistance, 1.0);
                // Apply exponential curve for more precision near center, more speed at edges
                joystickIntensity = linearIntensity * linearIntensity;

                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * maxDistance;
                    deltaY = Math.sin(angle) * maxDistance;
                }

                joystickDelta.x = deltaX / maxDistance;
                joystickDelta.y = deltaY / maxDistance;

                joystickStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                // Update keys object based on joystick position
                const threshold = 0.3;
                keys = {}; // Reset keys

                if (joystickDelta.y < -threshold) keys['w'] = true; // Forward
                if (joystickDelta.y > threshold) keys['s'] = true;  // Backward
                if (joystickDelta.x < -threshold) keys['a'] = true; // Left
                if (joystickDelta.x > threshold) keys['d'] = true;  // Right
            }
        }

        // Sprint Joystick Setup (looks like button, acts like joystick with sprint speed)
        function setupSprintButton() {
            const sprintBtn = document.getElementById('sprintBtn');
            const sprintIndicator = document.getElementById('sprintIndicator');
            const maxDistance = 45; // Max distance from center
            let sprintJoystickActive = false;

            sprintBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                sprintJoystickActive = true;
                sprintBtn.classList.add('active');
                updateSprintJoystick(e.touches[0]);
            }, { passive: false });

            sprintBtn.addEventListener('touchmove', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (sprintJoystickActive) {
                    updateSprintJoystick(e.touches[0]);
                }
            }, { passive: false });

            sprintBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                sprintJoystickActive = false;
                sprintBtn.classList.remove('active');

                // Clear sprint movement
                isShiftPressed = false;
                keys = {};
                joystickIntensity = 0;

                // Reset indicator to center
                sprintIndicator.style.transform = 'translate(-50%, -50%)';
            }, { passive: false });

            sprintBtn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                e.stopPropagation();
                sprintJoystickActive = false;
                sprintBtn.classList.remove('active');
                isShiftPressed = false;
                keys = {};
                joystickIntensity = 0;

                // Reset indicator to center
                sprintIndicator.style.transform = 'translate(-50%, -50%)';
            }, { passive: false });

            function updateSprintJoystick(touch) {
                const rect = sprintBtn.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Calculate intensity (0-1 based on how far joystick is pushed)
                joystickIntensity = Math.min(distance / maxDistance, 1.0);

                // Normalize delta to maxDistance
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * maxDistance;
                    deltaY = Math.sin(angle) * maxDistance;
                }

                const normalizedX = deltaX / maxDistance;
                const normalizedY = deltaY / maxDistance;

                // Update white dot indicator position
                sprintIndicator.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                // Always sprint when using this joystick
                isShiftPressed = true;

                // Update keys based on joystick position
                const threshold = 0.3;
                keys = {}; // Reset keys

                if (normalizedY < -threshold) keys['w'] = true; // Forward
                if (normalizedY > threshold) keys['s'] = true;  // Backward
                if (normalizedX < -threshold) keys['a'] = true; // Left
                if (normalizedX > threshold) keys['d'] = true;  // Right
            }
        }

        // Look Joystick Setup (controls camera rotation)
        function setupLookJoystick() {
            const lookZone = document.getElementById('lookJoystickZone');
            const lookStick = document.getElementById('lookJoystickStick');
            if (!lookZone || !lookStick) return;

            const maxDistance = 45; // Max distance from center
            let lookJoystickActive = false;
            let lookDelta = { x: 0, y: 0 };

            lookZone.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                lookJoystickActive = true;
                updateLookJoystick(e.touches[0]);
            }, { passive: false });

            lookZone.addEventListener('touchmove', (e) => {
                e.preventDefault();
                e.stopPropagation();
                if (lookJoystickActive) {
                    updateLookJoystick(e.touches[0]);
                }
            }, { passive: false });

            lookZone.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                lookJoystickActive = false;
                lookDelta = { x: 0, y: 0 };
                // Reset stick to center
                lookStick.style.transform = 'translate(-50%, -50%)';
            }, { passive: false });

            lookZone.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                e.stopPropagation();
                lookJoystickActive = false;
                lookDelta = { x: 0, y: 0 };
                lookStick.style.transform = 'translate(-50%, -50%)';
            }, { passive: false });

            function updateLookJoystick(touch) {
                const rect = lookZone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let deltaX = touch.clientX - centerX;
                let deltaY = touch.clientY - centerY;

                const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

                // Normalize delta to maxDistance
                if (distance > maxDistance) {
                    const angle = Math.atan2(deltaY, deltaX);
                    deltaX = Math.cos(angle) * maxDistance;
                    deltaY = Math.sin(angle) * maxDistance;
                }

                lookDelta.x = deltaX / maxDistance;
                lookDelta.y = deltaY / maxDistance;

                // Update stick visual position
                lookStick.style.transform = `translate(calc(-50% + ${deltaX}px), calc(-50% + ${deltaY}px))`;

                // Update camera rotation via yaw and pitch variables (used in animation loop)
                // lookDelta.x controls horizontal rotation (yaw)
                // lookDelta.y controls vertical rotation (pitch)
                const rotationSpeed = 0.05; // Adjust for sensitivity

                // Update TARGET yaw and pitch for smooth interpolation
                targetYaw -= lookDelta.x * rotationSpeed; // Yaw (left/right)
                targetPitch -= lookDelta.y * rotationSpeed; // Pitch (up/down)

                // Clamp target pitch to prevent over-rotation
                targetPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetPitch));
            }
        }

        // Play/Pause Button Setup
        function setupPlayButton() {
            const playBtn = document.getElementById('playBtn');

            playBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                playBtn.classList.add('active');
            }, { passive: false });

            playBtn.addEventListener('touchend', (e) => {
                e.preventDefault();
                e.stopPropagation();
                playBtn.classList.remove('active');

                // If we have a file currently playing, just toggle pause/resume
                if (currentFileId && wavesurfer) {
                    playPause();
                    setTimeout(updatePlayButtonIcon, 50);
                } else {
                    // No current file - check if there's a file at crosshair to play
                    const targetedFile = document.getElementById('targetedFile').textContent;

                    if (targetedFile && targetedFile !== 'None') {
                        // Trigger click at crosshair to play selected file
                        onClick({
                            target: renderer.domElement,
                            // No tapX/tapY means it uses center crosshair position
                        });
                        setTimeout(updatePlayButtonIcon, 100);
                    } else {
                        // Nothing playing, nothing targeted - do nothing or play first file
                        playPause();
                        setTimeout(updatePlayButtonIcon, 50);
                    }
                }
            }, { passive: false });

            playBtn.addEventListener('touchcancel', (e) => {
                e.preventDefault();
                e.stopPropagation();
                playBtn.classList.remove('active');
            }, { passive: false });
        }

        // Update play button icon to match player state
        function updatePlayButtonIcon() {
            const icon = document.getElementById('playBtnIcon');
            if (!icon) return;

            const isPlaying = wavesurfer && wavesurfer.isPlaying();
            icon.textContent = isPlaying ? '||' : '▶';
        }

        // Swipe to Look Setup - simple approach: use ANY touch not on joystick
        function setupSwipeToLook() {
            const canvas = renderer.domElement;
            const touchPositions = new Map(); // Track all touch positions
            const tapThreshold = 200; // ms
            const tapDistanceThreshold = 20; // pixels

            function isOnMobileControl(x, y) {
                // Check joystick
                const joystickZone = document.getElementById('joystickZone');
                const joystickRect = joystickZone.getBoundingClientRect();
                if (x >= joystickRect.left && x <= joystickRect.right &&
                    y >= joystickRect.top && y <= joystickRect.bottom) {
                    return true;
                }

                // Check play/pause button
                const playBtn = document.getElementById('playBtn');
                const playRect = playBtn.getBoundingClientRect();
                if (x >= playRect.left && x <= playRect.right &&
                    y >= playRect.top && y <= playRect.bottom) {
                    return true;
                }

                return false;
            }

            canvas.addEventListener('touchstart', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    if (!isOnMobileControl(touch.clientX, touch.clientY)) {
                        touchPositions.set(touch.identifier, {
                            startX: touch.clientX,
                            startY: touch.clientY,
                            lastX: touch.clientX,
                            lastY: touch.clientY,
                            startTime: Date.now()
                        });
                    }
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();

                // Process ALL active touches, use any that aren't on mobile controls for camera
                for (let i = 0; i < e.touches.length; i++) {
                    const touch = e.touches[i];
                    const tracked = touchPositions.get(touch.identifier);

                    if (tracked && !isOnMobileControl(touch.clientX, touch.clientY)) {
                        const deltaX = (touch.clientX - tracked.lastX) * lookSensitivity;
                        const deltaY = (touch.clientY - tracked.lastY) * lookSensitivity;

                        // Update targets for smooth camera movement (consistent with look joystick)
                        targetYaw -= deltaX;
                        targetPitch -= deltaY;
                        targetPitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, targetPitch));

                        // Also update actual values for immediate response
                        yaw -= deltaX;
                        pitch -= deltaY;
                        pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                        tracked.lastX = touch.clientX;
                        tracked.lastY = touch.clientY;
                    }
                }
            });

            canvas.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const touch = e.changedTouches[i];
                    const tracked = touchPositions.get(touch.identifier);

                    if (tracked) {
                        const touchDuration = Date.now() - tracked.startTime;
                        const touchDistance = Math.sqrt(
                            Math.pow(touch.clientX - tracked.startX, 2) +
                            Math.pow(touch.clientY - tracked.startY, 2)
                        );

                        // Quick tap = particle selection at tap location
                        if (touchDuration < tapThreshold && touchDistance < tapDistanceThreshold) {
                            onClick({
                                target: canvas,
                                tapX: touch.clientX,
                                tapY: touch.clientY
                            });
                        }

                        touchPositions.delete(touch.identifier);
                    }
                }
            });

            canvas.addEventListener('touchcancel', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    touchPositions.delete(e.changedTouches[i].identifier);
                }
            });
        }

        // Collapse panels by default on mobile
        function collapsePanelsOnMobile() {
            // Hide tag legend completely on mobile
            const tagLegend = document.getElementById('tagLegend');
            if (tagLegend) {
                tagLegend.style.display = 'none';
            }

            // Hide tag filter panel completely on mobile
            const tagFilterPanel = document.getElementById('tagFilterPanel');
            if (tagFilterPanel) {
                tagFilterPanel.style.display = 'none';
            }

            // Collapse all mode control sections
            const modeControlSections = document.querySelectorAll('.mode-controls h3');
            modeControlSections.forEach(header => {
                header.classList.add('collapsed');
                const content = header.nextElementSibling;
                if (content && content.classList.contains('collapsible-content')) {
                    content.classList.add('collapsed');
                }
            });
        }

        // Create particle sprite texture based on shape
        function createParticleTexture(shape) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d', { alpha: true });
            const centerX = 64;
            const centerY = 64;

            // Ensure transparent background
            ctx.clearRect(0, 0, 128, 128);

            switch(shape) {
                case 'circle':
                    // Soft circle with gradient - smooth falloff to transparent
                    const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 60);
                    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.8)');
                    gradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.3)');
                    gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 60, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'square':
                    // Square with gradient fade
                    const sqGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 50);
                    sqGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    sqGradient.addColorStop(0.7, 'rgba(255, 255, 255, 0.5)');
                    sqGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = sqGradient;
                    ctx.fillRect(14, 14, 100, 100);
                    break;

                case 'disc':
                    // Hard-edged circle with soft outer edge
                    const discGradient = ctx.createRadialGradient(centerX, centerY, 45, centerX, centerY, 58);
                    discGradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
                    discGradient.addColorStop(0.8, 'rgba(255, 255, 255, 1)');
                    discGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = discGradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 58, 0, Math.PI * 2);
                    ctx.fill();
                    break;

                case 'ring':
                    // Ring/donut shape with soft edges
                    const ringGradient = ctx.createRadialGradient(centerX, centerY, 30, centerX, centerY, 58);
                    ringGradient.addColorStop(0, 'rgba(255, 255, 255, 0)');
                    ringGradient.addColorStop(0.3, 'rgba(255, 255, 255, 1)');
                    ringGradient.addColorStop(0.7, 'rgba(255, 255, 255, 1)');
                    ringGradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
                    ctx.fillStyle = ringGradient;
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 58, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'destination-out';
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, 30, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    break;
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }

        // Add stars background
        function addStarsBackground() {
            // Create space skybox using shader material for gradient
            const skyboxGeometry = new THREE.SphereGeometry(visibilityDistance * 1.5, 32, 32);
            const skyboxMaterial = new THREE.ShaderMaterial({
                uniforms: {},
                vertexShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vWorldPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec3 vWorldPosition;
                    void main() {
                        // Deep space gradient: dark blue to black
                        vec3 topColor = vec3(0.02, 0.02, 0.08);  // Very dark blue
                        vec3 bottomColor = vec3(0.0, 0.0, 0.0);   // Black

                        float h = normalize(vWorldPosition).y * 0.5 + 0.5;
                        vec3 color = mix(bottomColor, topColor, h);

                        gl_FragColor = vec4(color, 1.0);
                    }
                `,
                side: THREE.BackSide
            });

            const skybox = new THREE.Mesh(skyboxGeometry, skyboxMaterial);
            scene.add(skybox);

            // Add stars with varied sizes and brightness
            const starsGeometry = new THREE.BufferGeometry();
            const starsVertices = [];
            const starsSizes = [];
            const starsColors = [];

            for (let i = 0; i < 5000; i++) {
                const x = (Math.random() - 0.5) * visibilityDistance * 1.8;
                const y = (Math.random() - 0.5) * visibilityDistance * 1.8;
                const z = (Math.random() - 0.5) * visibilityDistance * 1.8;
                starsVertices.push(x, y, z);

                // Varied star sizes for depth
                const size = Math.random() * 1.5 + 0.2;
                starsSizes.push(size);

                // Varied star colors (white to blue-white)
                const brightness = 0.7 + Math.random() * 0.3;
                starsColors.push(brightness, brightness, brightness + 0.1);
            }

            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            starsGeometry.setAttribute('size', new THREE.Float32BufferAttribute(starsSizes, 1));
            starsGeometry.setAttribute('color', new THREE.Float32BufferAttribute(starsColors, 3));

            const starsMaterial = new THREE.PointsMaterial({
                size: 0.5,
                vertexColors: true,
                transparent: true,
                opacity: 0.8,
                sizeAttenuation: true
            });

            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }

        // Load data from Supabase
        // Toggle database dropdown
        function toggleDbDropdown() {
            const dropdown = document.getElementById('dbDropdown');
            dropdown.classList.toggle('active');
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('dbDropdown');
            if (dropdown && !dropdown.contains(event.target)) {
                dropdown.classList.remove('active');
            }
        });

        // Toggle database source checkbox
        function toggleDbSource(source, event) {
            event.stopPropagation(); // Prevent dropdown from closing

            const checkbox = document.getElementById(source === 'audioFiles' ? 'sourceAudioFiles' : 'sourceAudioStems');
            checkbox.checked = !checkbox.checked;

            // Sync with Galaxy Menu checkbox
            const galaxyCheckbox = document.getElementById(source === 'audioFiles' ? 'galaxySourceAudioFiles' : 'galaxySourceAudioStems');
            if (galaxyCheckbox) {
                galaxyCheckbox.checked = checkbox.checked;
            }

            updateDataSources();
        }

        // Update data sources when selection changes
        async function updateDataSources() {
            console.log('=== updateDataSources() called ===');
            const audioFilesChecked = document.getElementById('sourceAudioFiles').checked;
            const stemsChecked = document.getElementById('sourceAudioStems').checked;

            console.log(`Audio Files: ${audioFilesChecked}, Stems: ${stemsChecked}`);

            // Update label
            const label = document.getElementById('dbDropdownLabel');
            if (audioFilesChecked && stemsChecked) {
                label.textContent = 'Both Sources';
            } else if (stemsChecked) {
                label.textContent = 'Stems Only';
            } else {
                label.textContent = 'Audio Files';
            }

            // Reload data
            const loadingScreen = document.getElementById('loadingScreen');
            loadingScreen.classList.remove('hidden');

            console.log('About to call loadData()...');
            await loadData();
            console.log('loadData() completed');

            loadingScreen.classList.add('hidden');
        }

        async function loadData() {
            try {
                const includeAudioFiles = document.getElementById('sourceAudioFiles').checked;
                const includeStems = document.getElementById('sourceAudioStems').checked;

                // IMPORTANT: Clear the array completely before loading
                audioFiles = [];
                console.log('loadData() called - audioFiles array cleared');

                // Load regular audio files
                if (includeAudioFiles) {
                    const { data, error } = await supabase
                        .from('audio_files')
                        .select('*')
                        .order('created_at', { ascending: false});

                    if (error) throw error;

                    // Mark source for each file and create unique composite ID
                    const filesWithSource = (data || []).map(file => ({
                        ...file,
                        id: `audio_files_${file.id}`, // Unique composite ID
                        _originalId: file.id,          // Keep original ID
                        _source: 'audio_files',
                        _galaxyOffset: { x: 0, y: 0, z: 0 } // Galaxy 1 at origin
                    }));

                    audioFiles.push(...filesWithSource);
                }

                // Load stems (client-side join since FK relationship doesn't exist)
                if (includeStems) {
                    console.log('Loading stems...');
                    // First, get all stems
                    const { data: stemsData, error: stemsError } = await supabase
                        .from('audio_files_stems')
                        .select('*')
                        .order('created_at', { ascending: false });

                    if (stemsError) {
                        console.error('Stems query error:', stemsError);
                        throw stemsError;
                    }

                    console.log(`Fetched ${stemsData.length} stems from database`);

                    // Get unique parent audio_file_ids
                    const parentIds = [...new Set(stemsData.map(s => s.audio_file_id))];

                    // Fetch parent files data (including file_url for waveform display)
                    const { data: parentFiles, error: parentError } = await supabase
                        .from('audio_files')
                        .select('*')  // Get all fields including file_url
                        .in('id', parentIds);

                    if (parentError) {
                        console.error('Parent files query error:', parentError);
                        console.error('Parent IDs that failed:', parentIds);
                        console.error('Full parent error:', JSON.stringify(parentError, null, 2));
                        throw parentError;
                    }

                    console.log(`Fetched ${parentFiles.length} parent files for stem lookup`);

                    // Create lookup map for parent data
                    const parentMap = {};
                    parentFiles.forEach(parent => {
                        parentMap[parent.id] = parent;
                    });

                    // If Audio Files checkbox is unchecked, still add parent files to audioFiles
                    // but mark them as hidden (for waveform/metadata use only, not for particle display)
                    if (!includeAudioFiles && parentFiles.length > 0) {
                        console.log('Adding parent files for stem waveform display (hidden from particles)');
                        const parentFilesForWaveform = parentFiles.map(file => ({
                            ...file,
                            id: `audio_files_${file.id}`, // Unique composite ID
                            _originalId: file.id,          // Keep original ID
                            _source: 'audio_files',
                            _hiddenFromParticles: true,    // Mark as hidden from particle system
                            _galaxyOffset: { x: 0, y: 0, z: 0 }
                        }));
                        audioFiles.push(...parentFilesForWaveform);
                        console.log(`Added ${parentFilesForWaveform.length} hidden parent files for waveform use`);
                    }

                    // Transform stems to match audio_files structure
                    const stemsWithParentData = stemsData.map(stem => {
                        const parent = parentMap[stem.audio_file_id] || {};
                        const stemName = stem.stem_file_name || `${stem.stem_type}_stem`;
                        return {
                            id: `audio_files_stems_${stem.id}`, // Unique composite ID
                            _originalId: stem.id,                // Keep original ID
                            name: stemName,                      // For player display
                            file_name: stemName,                 // For compatibility
                            file_url: stem.file_url,
                            file_size: stem.file_size,
                            bpm: stem.bpm,
                            key: stem.key,
                            created_at: stem.created_at,
                            // Inherit from parent
                            tags: parent.tags || [],
                            length: parent.length || null,
                            // Stem-specific
                            stem_type: stem.stem_type,
                            empty_status: stem.empty_status,
                            audio_file_id: stem.audio_file_id,
                            _source: 'audio_files_stems',
                            _galaxyOffset: { x: stemGalaxyOffset, y: 0, z: 0 } // Galaxy 2 offset (configurable)
                        };
                    });

                    console.log(`Transformed ${stemsWithParentData.length} stems, about to add to audioFiles (current count: ${audioFiles.length})`);
                    audioFiles.push(...stemsWithParentData);
                    console.log(`After adding stems, audioFiles count: ${audioFiles.length}`);
                }

                console.log(`Loaded ${audioFiles.length} total items from ${includeAudioFiles ? 'audio_files ' : ''}${includeStems ? 'stems' : ''}`);

                // Check for duplicate IDs (debugging)
                const idCounts = new Map();
                audioFiles.forEach(file => {
                    idCounts.set(file.id, (idCounts.get(file.id) || 0) + 1);
                });
                const duplicates = Array.from(idCounts.entries()).filter(([id, count]) => count > 1);
                if (duplicates.length > 0) {
                    console.warn('DUPLICATE IDs FOUND:', duplicates);
                    duplicates.forEach(([id, count]) => {
                        console.warn(`ID ${id} appears ${count} times`);
                        const dupes = audioFiles.filter(f => f.id === id);
                        console.warn('Duplicate files:', dupes);
                    });
                }

                // IMPORTANT: Detect frequent tags BEFORE creating particles
                detectFrequentTags();

                updateStats();
                createParticles();

                // Hide loading screen
                document.getElementById('loadingScreen').classList.add('hidden');
            } catch (error) {
                console.error('Error loading data:', error);
                // Only show alert for critical errors, not for missing DOM elements during initialization
                if (error.message && !error.message.includes('null')) {
                    console.error('Critical error loading files. Check console for details.');
                }
            }
        }

        // Create particle system - clusters of particles per file using InstancedMesh
        function createParticles() {
            particles = [];

            // Remove old particle system if it exists
            if (particleSystem) {
                scene.remove(particleSystem);
                if (particleSystem.geometry) particleSystem.geometry.dispose();
                if (particleSystem.material) particleSystem.material.dispose();
            }

            // Calculate particles per cluster
            const densityAddition = Math.floor(densityGradient * particlesPerCluster);
            const maxParticlesPerCluster = particlesPerCluster + densityAddition;

            // Filter out hidden files (parent files loaded only for waveform use)
            const visibleFiles = audioFiles.filter(f => !f._hiddenFromParticles);

            // Calculate total particles needed (all visible files get full clusters now)
            let totalParticlesNeeded = visibleFiles.length * maxParticlesPerCluster;

            // Apply max particle limit if set
            let count = totalParticlesNeeded;
            let particleReductionFactor = 1.0;

            if (maxParticleCount > 0 && totalParticlesNeeded > maxParticleCount) {
                count = maxParticleCount;
                particleReductionFactor = maxParticleCount / totalParticlesNeeded;
                console.log(`Particle limit active: ${totalParticlesNeeded} requested, ${maxParticleCount} max. Reduction factor: ${particleReductionFactor.toFixed(2)}`);
            }

            // Create geometry - simple plane sprite (smaller for sub-particles)
            const geometry = new THREE.PlaneGeometry(1, 1);

            // Create material with texture
            const material = new THREE.MeshBasicMaterial({
                map: createParticleTexture(particleShape),
                transparent: true,
                opacity: particleBrightness,
                blending: THREE.AdditiveBlending,
                side: THREE.DoubleSide,
                depthWrite: false
            });

            // Create instanced mesh with total particle count
            particleSystem = new THREE.InstancedMesh(geometry, material, count);
            particleSystem.instanceMatrix.setUsage(THREE.DynamicDrawUsage);

            const dummy = new THREE.Object3D();
            const color = new THREE.Color();
            let instanceIndex = 0;

            // Only create particles for visible files
            visibleFiles.forEach((file, fileIndex) => {
                const centerPos = calculateFilePosition(file, fileIndex);

                // Color based on CURRENT MODE
                const colorData = getColorForFile(file);
                const baseColor = new THREE.Color().setHSL(colorData.hue / 360, colorData.sat, 0.6);

                // Store cluster data
                const cluster = {
                    file,
                    centerPosition: new THREE.Vector3(centerPos.x, centerPos.y, centerPos.z),
                    color: baseColor.clone(),
                    colorData,
                    fileIndex,
                    subParticles: []
                };

                // Calculate total particles including density gradient additions
                const baseParticles = particlesPerCluster;
                const densityAddition = Math.floor(densityGradient * baseParticles);
                let totalParticles = baseParticles + densityAddition;

                // Apply particle reduction if limit is active
                if (particleReductionFactor < 1.0) {
                    totalParticles = Math.max(1, Math.floor(totalParticles * particleReductionFactor));
                }

                // Create sub-particles based on selected shape
                for (let i = 0; i < totalParticles; i++) {
                    let offsetX, offsetY, offsetZ;
                    let isCenterParticle = false;
                    let radiusVariation = 0;

                    // First 2 particles are at the center to mark cluster position
                    if (i < 2) {
                        offsetX = 0;
                        offsetY = 0;
                        offsetZ = 0;
                        isCenterParticle = true;
                        radiusVariation = 0;
                    } else {
                        // Generate distribution based on shape mode - use seeded random for consistency
                        const seed = fileIndex * 10000 + i;
                        const theta = seededRandom(seed * 2) * Math.PI * 2;
                        const phi = Math.acos(2 * seededRandom(seed * 2 + 1) - 1);

                        // Determine if this is a density gradient particle (extra particles near center)
                        const isDensityParticle = i >= baseParticles;

                        if (isDensityParticle) {
                            // Density gradient particles: bias towards center with smooth falloff
                            // Use power function for smooth gradient: closer particles are more likely
                            const randomRadius = seededRandom(seed * 3);
                            radiusVariation = Math.pow(randomRadius, 2.0) * 0.6; // Squared for more center weighting, max 0.6 distance
                        } else if (subParticleShape === 'sphere') {
                            // Uniform sphere - all particles at same distance
                            radiusVariation = 1.0;
                        } else if (subParticleShape === 'spiked') {
                            // Spiked - particles at inner or outer sphere
                            radiusVariation = seededRandom(seed * 3) < 0.5 ? 0.4 : 1.0;
                        } else {
                            // Default - organic distribution
                            radiusVariation = 0.5 + seededRandom(seed * 3) * 0.5; // 0.5-1.0 variation
                        }

                        offsetX = clusterRadius * Math.sin(phi) * Math.cos(theta) * radiusVariation;
                        offsetY = clusterRadius * Math.sin(phi) * Math.sin(theta) * radiusVariation;
                        offsetZ = clusterRadius * Math.cos(phi) * radiusVariation;
                    }

                    // Calculate actual distance from center (0-1 normalized)
                    const actualDistance = Math.sqrt(offsetX * offsetX + offsetY * offsetY + offsetZ * offsetZ) / clusterRadius;

                    // Sub-particle position relative to center
                    const subParticle = {
                        offset: new THREE.Vector3(offsetX, offsetY, offsetZ),
                        instanceIndex: instanceIndex,
                        orbitPhase: seededRandom(fileIndex * 10000 + i + 999) * Math.PI * 2,  // Seeded phase for consistency
                        isCenterParticle: isCenterParticle,
                        baseRadius: radiusVariation,  // Store original radius variation (0.5-1.0, or 0 for center)
                        distanceFromCenter: actualDistance,  // Actual normalized distance 0-1 for gradients
                        // Random orbit parameters for 'random' motion path
                        randomOrbitAxis: new THREE.Vector3(
                            seededRandom(fileIndex * 20000 + i) * 2 - 1,
                            seededRandom(fileIndex * 30000 + i) * 2 - 1,
                            seededRandom(fileIndex * 40000 + i) * 2 - 1
                        ).normalize(),
                        randomOrbitSpeed: 0.5 + seededRandom(fileIndex * 50000 + i) * 1.5  // Speed variation 0.5-2.0x
                    };

                    cluster.subParticles.push(subParticle);

                    // Set initial position for this sub-particle instance
                    dummy.position.set(
                        centerPos.x + offsetX,
                        centerPos.y + offsetY,
                        centerPos.z + offsetZ
                    );
                    dummy.scale.setScalar(particleSize * subParticleScale); // Smaller sub-particles
                    dummy.updateMatrix();

                    particleSystem.setMatrixAt(instanceIndex, dummy.matrix);

                    // Center particles get brighter, no color variation
                    if (isCenterParticle) {
                        color.setHSL(
                            colorData.hue / 360,
                            colorData.sat,
                            0.8 // Brighter center
                        );
                    } else {
                        // Add slight color variation to outer sub-particles for visual interest - use seeded random
                        const colorSeed = fileIndex * 10000 + i + 5000;
                        const hueShift = (seededRandom(colorSeed) - 0.5) * 0.05; // ±5% hue shift

                        // Base brightness
                        let baseLightness = 0.6 + (seededRandom(colorSeed + 1) - 0.5) * 0.1;

                        color.setHSL(
                            (colorData.hue / 360 + hueShift + 1) % 1,
                            colorData.sat,
                            baseLightness
                        );
                    }
                    particleSystem.setColorAt(instanceIndex, color);

                    instanceIndex++;
                }

                // Initialize hover time tracking
                cluster.customTime = null;  // Each cluster tracks its own time (null = use global time)
                cluster.lastRealTime = null; // Track last real animation time for delta calculations

                particles.push(cluster);
            });

            particleSystem.instanceMatrix.needsUpdate = true;
            if (particleSystem.instanceColor) {
                particleSystem.instanceColor.needsUpdate = true;
            }

            scene.add(particleSystem);
            console.log(`Created ${particles.length} clusters with ${count} total particles`);

            // Update Galaxy Menu (Options 2) with current values
            if (typeof populateGalaxyMenu === 'function') {
                populateGalaxyMenu();
            }
        }

        // Simple seeded random number generator for consistent positions
        function seededRandom(seed) {
            const x = Math.sin(seed) * 10000;
            return x - Math.floor(x);
        }

        // Calculate 3D position for a file based on current modes
        function calculateFilePosition(file, index) {
            // Use current axis modes
            let x = calculateAxisValue(file, currentXMode, 100);
            let y = calculateAxisValue(file, currentYMode, 80);
            let z = calculateAxisValue(file, currentZMode, 60);

            // Add slight randomness to prevent exact overlaps - use seeded random for consistency
            x += (seededRandom(index * 3 + 1) - 0.5) * 2;
            y += (seededRandom(index * 3 + 2) - 0.5) * 2;
            z += (seededRandom(index * 3 + 3) - 0.5) * 2;

            // Apply axis scaling
            x *= xAxisScale;
            y *= yAxisScale;
            z *= zAxisScale;

            // Apply galaxy offset for multi-table mode
            if (file._galaxyOffset) {
                x += file._galaxyOffset.x;
                y += file._galaxyOffset.y;
                z += file._galaxyOffset.z;
            }

            return { x, y, z };
        }

        // Update stats display
        function updateStats() {
            document.getElementById('totalFiles').textContent = audioFiles.length;

            const bpms = audioFiles.filter(f => f.bpm).map(f => f.bpm);
            if (bpms.length > 0) {
                const minBpm = Math.min(...bpms);
                const maxBpm = Math.max(...bpms);
                document.getElementById('bpmRange').textContent = `${minBpm} - ${maxBpm}`;
            }

            // Update tag legend
            updateTagLegend();
        }

        // Update legend based on current color mode
        function updateTagLegend() {
            const legendContent = document.getElementById('tagLegendContent');
            legendContent.innerHTML = '';

            if (currentColorMode === 'tags') {
                updateTagsLegend(legendContent);
            } else if (currentColorMode === 'key') {
                updateKeysLegend(legendContent);
            } else if (currentColorMode === 'bpm') {
                updateBPMLegend(legendContent);
            } else if (currentColorMode === 'length') {
                updateLengthLegend(legendContent);
            }
        }

        // Legend for tags mode
        function updateTagsLegend(container) {
            const categoryCounts = new Map();
            audioFiles.forEach(file => {
                const category = getCategoryForFile(file);
                categoryCounts.set(category, (categoryCounts.get(category) || 0) + 1);
            });

            // Sort categories: main predefined first, then auto-detected by count, then 'other'
            const mainOrder = ['drm', 'inst', 'vox', 'bass', 'gtr', 'pno', 'piano', 'syn', 'perc', 'pad', 'lead', 'fx', 'arp'];
            const sortedCategories = [];

            // Add main categories that exist
            mainOrder.forEach(cat => {
                if (categoryCounts.has(cat)) {
                    sortedCategories.push([cat, categoryCounts.get(cat)]);
                }
            });

            // Add auto-detected categories sorted by file count
            const autoDetected = [];
            autoDetectedCategories.forEach((color, category) => {
                if (categoryCounts.has(category)) {
                    autoDetected.push([category, categoryCounts.get(category)]);
                }
            });
            autoDetected.sort((a, b) => b[1] - a[1]); // Sort by count descending
            sortedCategories.push(...autoDetected);

            // Add 'other' last if it exists
            if (categoryCounts.has('other')) {
                sortedCategories.push(['other', categoryCounts.get('other')]);
            }

            sortedCategories.forEach(([category, count]) => {
                const colorData = getColorForCategory(category);
                const color = new THREE.Color().setHSL(colorData.hue / 360, colorData.sat, 0.6);
                const hexColor = '#' + color.getHexString();
                const displayName = mainCategoryColors[category] ? category.toUpperCase() : category;

                const item = document.createElement('div');
                item.className = 'tag-legend-item';
                item.dataset.category = category; // For search filtering

                const colorDot = document.createElement('div');
                colorDot.className = 'tag-legend-color';
                colorDot.style.background = hexColor;
                colorDot.style.cursor = 'pointer';

                // Set initial visual state based on hiddenCategories
                if (hiddenCategories.has(category)) {
                    colorDot.style.opacity = '0.3';
                    colorDot.style.filter = 'grayscale(100%)';
                }

                const nameDiv = document.createElement('div');
                nameDiv.className = 'tag-legend-name';
                nameDiv.textContent = displayName;
                nameDiv.style.cursor = 'pointer';

                const countDiv = document.createElement('div');
                countDiv.className = 'tag-legend-count';
                countDiv.textContent = count;

                // Click color dot to toggle visibility
                colorDot.onclick = (e) => {
                    e.stopPropagation();
                    if (hiddenCategories.has(category)) {
                        hiddenCategories.delete(category);
                        colorDot.style.opacity = '1';
                        colorDot.style.filter = 'none';
                    } else {
                        hiddenCategories.add(category);
                        colorDot.style.opacity = '0.3';
                        colorDot.style.filter = 'grayscale(100%)';
                    }
                };

                // Click title/name to play random file from category (respecting all filters)
                nameDiv.onclick = (e) => {
                    e.stopPropagation();
                    const eligibleFiles = getEligibleFiles();
                    const filesInCategory = eligibleFiles.filter(f => getCategoryForFile(f) === category);
                    if (filesInCategory.length > 0) {
                        const randomFile = filesInCategory[Math.floor(Math.random() * filesInCategory.length)];
                        loadAndPlayFile(randomFile);
                    }
                };

                item.appendChild(colorDot);
                item.appendChild(nameDiv);
                item.appendChild(countDiv);
                container.appendChild(item);
            });
        }

        // Legend for key mode
        function updateKeysLegend(container) {
            const keyCounts = new Map();
            audioFiles.forEach(file => {
                const key = file.key || 'No Key';
                keyCounts.set(key, (keyCounts.get(key) || 0) + 1);
            });

            const sortedKeys = Array.from(keyCounts.entries()).sort((a, b) => b[1] - a[1]);

            sortedKeys.forEach(([key, count]) => {
                const colorData = getColorByKey(key);
                const color = new THREE.Color().setHSL(colorData.hue / 360, colorData.sat, 0.6);
                const hexColor = '#' + color.getHexString();

                const item = document.createElement('div');
                item.className = 'tag-legend-item';
                item.innerHTML = `
                    <div class="tag-legend-color" style="background: ${hexColor};"></div>
                    <div class="tag-legend-name">${key}</div>
                    <div class="tag-legend-count">${count}</div>
                `;
                container.appendChild(item);
            });
        }

        // Legend for BPM mode
        function updateBPMLegend(container) {
            const bpmRanges = [
                { name: '< 80 BPM', count: 0 },
                { name: '80-99 BPM', count: 0 },
                { name: '100-119 BPM', count: 0 },
                { name: '120-139 BPM', count: 0 },
                { name: '140-159 BPM', count: 0 },
                { name: '160+ BPM', count: 0 },
                { name: 'No BPM', count: 0 }
            ];

            audioFiles.forEach(file => {
                const bpm = file.bpm;
                if (!bpm) bpmRanges[6].count++;
                else if (bpm < 80) bpmRanges[0].count++;
                else if (bpm < 100) bpmRanges[1].count++;
                else if (bpm < 120) bpmRanges[2].count++;
                else if (bpm < 140) bpmRanges[3].count++;
                else if (bpm < 160) bpmRanges[4].count++;
                else bpmRanges[5].count++;
            });

            bpmRanges.forEach(range => {
                if (range.count > 0) {
                    const colorData = getColorByBPM(range.name === 'No BPM' ? null : parseInt(range.name));
                    const color = new THREE.Color().setHSL(colorData.hue / 360, colorData.sat, 0.6);
                    const hexColor = '#' + color.getHexString();

                    const item = document.createElement('div');
                    item.className = 'tag-legend-item';
                    item.innerHTML = `
                        <div class="tag-legend-color" style="background: ${hexColor};"></div>
                        <div class="tag-legend-name">${range.name}</div>
                        <div class="tag-legend-count">${range.count}</div>
                    `;
                    container.appendChild(item);
                }
            });
        }

        // Legend for Length mode
        function updateLengthLegend(container) {
            const lengthRanges = [
                { name: '< 30s', count: 0 },
                { name: '30s-1min', count: 0 },
                { name: '1-2min', count: 0 },
                { name: '2-3min', count: 0 },
                { name: '3-4min', count: 0 },
                { name: '4-5min', count: 0 },
                { name: '5min+', count: 0 },
                { name: 'No Length', count: 0 }
            ];

            audioFiles.forEach(file => {
                const length = file.length;
                if (!length) lengthRanges[7].count++;
                else if (length < 30) lengthRanges[0].count++;
                else if (length < 60) lengthRanges[1].count++;
                else if (length < 120) lengthRanges[2].count++;
                else if (length < 180) lengthRanges[3].count++;
                else if (length < 240) lengthRanges[4].count++;
                else if (length < 300) lengthRanges[5].count++;
                else lengthRanges[6].count++;
            });

            lengthRanges.forEach(range => {
                if (range.count > 0) {
                    const colorData = getColorByLength(range.name === 'No Length' ? null :
                        range.name === '< 30s' ? 15 :
                        range.name === '30s-1min' ? 45 :
                        range.name === '1-2min' ? 90 :
                        range.name === '2-3min' ? 150 :
                        range.name === '3-4min' ? 210 :
                        range.name === '4-5min' ? 270 : 330);
                    const color = new THREE.Color().setHSL(colorData.hue / 360, colorData.sat, 0.6);
                    const hexColor = '#' + color.getHexString();

                    const item = document.createElement('div');
                    item.className = 'tag-legend-item';
                    item.innerHTML = `
                        <div class="tag-legend-color" style="background: ${hexColor};"></div>
                        <div class="tag-legend-name">${range.name}</div>
                        <div class="tag-legend-count">${range.count}</div>
                    `;
                    container.appendChild(item);
                }
            });
        }

        // Recreate particles (used by Options 2 UI elements)
        function recreateParticles() {
            createParticles();
            updateTagLegend();
        }

        // Apply visualization mode changes
        function applyVisualizationModes() {
            // Get values from Options 2 dropdowns (galaxy* prefixed)
            const colorModeEl = document.getElementById('galaxyColorMode');
            const xAxisModeEl = document.getElementById('galaxyXAxisMode');
            const yAxisModeEl = document.getElementById('galaxyYAxisMode');
            const zAxisModeEl = document.getElementById('galaxyZAxisMode');

            if (colorModeEl) currentColorMode = colorModeEl.value;
            if (xAxisModeEl) currentXMode = xAxisModeEl.value;
            if (yAxisModeEl) currentYMode = yAxisModeEl.value;
            if (zAxisModeEl) currentZMode = zAxisModeEl.value;

            // Rebuild particles with new settings
            recreateParticles();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Increment animation time for swirling
            animationTime += orbitSpeed;

            // Update audio reactivity
            updateAudioAmplitude();

            // FPS movement
            updateMovement();

            // Update camera position display
            const pos = camera.position;
            document.getElementById('cameraPos').textContent =
                `${pos.x.toFixed(0)}, ${pos.y.toFixed(0)}, ${pos.z.toFixed(0)}`;

            // Update info window
            updateInfoWindow();

            // Update audio amplitude displays
            document.getElementById('audioAmplitudeDisplay').textContent = currentAudioAmplitude.toFixed(2);
            document.getElementById('bassAmplitudeDisplay').textContent = bassAmplitude.toFixed(2);
            document.getElementById('midsAmplitudeDisplay').textContent = midsAmplitude.toFixed(2);
            document.getElementById('highsAmplitudeDisplay').textContent = highsAmplitude.toFixed(2);

            // Update particle positions based on rotation mode
            if (particleSystem && motionEnabled) {
                const dummy = new THREE.Object3D();

                particles.forEach((cluster, clusterIndex) => {
                    // Check if this cluster is hovered (via crosshair)
                    const isHovered = (hoveredCluster === cluster);

                    // Calculate per-cluster time - simple approach
                    let clusterAnimationTime;

                    // Calculate delta time since last frame
                    const deltaTime = cluster.lastRealTime !== null ? (animationTime - cluster.lastRealTime) : 0;
                    cluster.lastRealTime = animationTime;

                    // Initialize custom time if needed
                    if (cluster.customTime === null) {
                        cluster.customTime = animationTime;
                    }

                    // Advance custom time based on hover state
                    if (isHovered && mouseInteractionEnabled) {
                        // Hovering: advance at slow speed
                        cluster.customTime += deltaTime * hoverSlowdown;
                    } else {
                        // Not hovering: advance at normal speed
                        cluster.customTime += deltaTime;
                    }

                    clusterAnimationTime = cluster.customTime;

                    // Calculate audio-reactive spread factor per cluster
                    let spreadFactor = 1.0;

                    // In multi-stem mode, check if this cluster is one of the playing stems
                    let isPlayingCluster;
                    if (isMultiStemMode && currentPlayingStems.length > 0) {
                        isPlayingCluster = currentPlayingStems.some(stem => stem.id === cluster.file.id);
                    } else {
                        isPlayingCluster = (cluster.file.id === currentFileId);
                    }

                    if (audioReactivityEnabled && currentAudioAmplitude > 0) {
                        if (isPlayingCluster) {
                            // Currently playing cluster uses full spread
                            spreadFactor = 1.0 + currentAudioAmplitude * clusterSpreadOnAudio * 0.1;
                        } else if (globalAudioReactivity > 0) {
                            // Other clusters use global reactivity for subtle spread
                            spreadFactor = 1.0 + currentAudioAmplitude * (globalAudioReactivity * 0.1);
                        }
                    }
                    const basePos = cluster.centerPosition;
                    let centerX = basePos.x;
                    let centerY = basePos.y;
                    let centerZ = basePos.z;

                    // Apply galaxy motion to cluster center
                    if (rotationMode === 'collective') {
                        // COLLECTIVE: All clusters rotate together as spikes on a sphere
                        const angle = clusterAnimationTime * 1000;
                        const amplitudeScale = orbitRadius * 0.1;

                        if (rotationAxis === 'y' || rotationAxis === 'all') {
                            const cosY = Math.cos(angle);
                            const sinY = Math.sin(angle);
                            const tempX = (basePos.x * amplitudeScale) * cosY - (basePos.z * amplitudeScale) * sinY;
                            const tempZ = (basePos.x * amplitudeScale) * sinY + (basePos.z * amplitudeScale) * cosY;
                            centerX = tempX;
                            centerZ = tempZ;
                        }

                        if (rotationAxis === 'x' || rotationAxis === 'all') {
                            const cosX = Math.cos(angle * 0.7);
                            const sinX = Math.sin(angle * 0.7);
                            const tempY = (centerY * amplitudeScale) * cosX - centerZ * sinX;
                            const tempZ = (centerY * amplitudeScale) * sinX + centerZ * cosX;
                            centerY = tempY;
                            centerZ = tempZ;
                        }

                        if (rotationAxis === 'z' || rotationAxis === 'all') {
                            const cosZ = Math.cos(angle * 0.5);
                            const sinZ = Math.sin(angle * 0.5);
                            const tempX = centerX * cosZ - (centerY * amplitudeScale) * sinZ;
                            const tempY = centerX * sinZ + (centerY * amplitudeScale) * cosZ;
                            centerX = tempX;
                            centerY = tempY;
                        }

                    } else if (rotationMode === 'spiral') {
                        // SPIRAL: Galaxy arm rotation
                        const dx = basePos.x - galaxyCenterX;
                        const dz = basePos.z - galaxyCenterZ;
                        const distanceFromCenter = Math.sqrt(dx * dx + dz * dz);
                        const angle = Math.atan2(dz, dx);
                        const rotationAngle = angle + (clusterAnimationTime * 1000 * (1 + distanceFromCenter * 0.01));

                        const spiralX = Math.cos(rotationAngle) * distanceFromCenter;
                        const spiralZ = Math.sin(rotationAngle) * distanceFromCenter;
                        const driftX = (spiralX - dx) * (orbitRadius * 0.01);
                        const driftZ = (spiralZ - dz) * (orbitRadius * 0.01);

                        centerX = basePos.x + driftX;
                        centerZ = basePos.z + driftZ;

                    } else if (rotationMode === 'individual') {
                        // INDIVIDUAL: Each cluster orbits around its own position
                        const offset = clusterIndex * 0.1;
                        centerX = basePos.x + Math.sin(clusterAnimationTime * 1000 + offset) * orbitRadius;
                        centerZ = basePos.z + Math.cos(clusterAnimationTime * 1000 + offset) * orbitRadius;
                        centerY = basePos.y + Math.sin(clusterAnimationTime * 800 + offset * 0.7) * (orbitRadius * 0.3);
                    }

                    // Apply mouse interaction to cluster center if enabled
                    if (false && mouseInteractionEnabled && !isPointerLocked) {
                        const dx = centerX - mouseWorldPos.x;
                        const dy = centerY - mouseWorldPos.y;
                        const dz = centerZ - mouseWorldPos.z;
                        const distance = Math.sqrt(dx * dx + dy * dy + dz * dz);

                        if (distance < mouseInteractionRadius) {
                            const force = (1 - distance / mouseInteractionRadius) * mouseInteractionStrength;
                            const pushX = (dx / distance) * force;
                            const pushY = (dy / distance) * force;
                            const pushZ = (dz / distance) * force;

                            centerX += pushX;
                            centerY += pushY;
                            centerZ += pushZ;
                        }
                    }

                    // Now update all sub-particles in this cluster
                    cluster.subParticles.forEach(subParticle => {
                        let finalX, finalY, finalZ;

                        // Center particles stay at cluster center (no orbit, no spread)
                        if (subParticle.isCenterParticle) {
                            finalX = centerX;
                            finalY = centerY;
                            finalZ = centerZ;
                        } else {
                            // Start with base offset position (scaled by spread factor)
                            const baseX = centerX + subParticle.offset.x * spreadFactor;
                            const baseY = centerY + subParticle.offset.y * spreadFactor;
                            const baseZ = centerZ + subParticle.offset.z * spreadFactor;

                            // Add individual orbital motion around each sub-particle's position
                            if (subParticleMotionPath === 'static' || subParticleMotionSpeed === 0) {
                                // Static - no motion, particles stay at their spawned positions
                                finalX = baseX;
                                finalY = baseY;
                                finalZ = baseZ;
                            } else if (subParticleMotionPath === 'natural') {
                                // Natural - simple rotation around cluster center
                                // subParticleAnimationSpeed controls rotation speed
                                // subParticleMotionSpeed controls orbit radius/distance from center
                                const time = clusterAnimationTime * subParticleAnimationSpeed * 0.5;
                                const rotationAngle = time + subParticle.orbitPhase;

                                // Use subParticleMotionSpeed as radius multiplier (like other modes)
                                const radiusScale = subParticleMotionSpeed > 0 ? subParticleMotionSpeed * 0.5 : 1.0;

                                // Rotate around cluster center (not around spawn point)
                                const dx = subParticle.offset.x * radiusScale;
                                const dy = subParticle.offset.y * radiusScale;
                                const dz = subParticle.offset.z * radiusScale;

                                // Simple rotation around Y axis (vertical)
                                const rotatedX = dx * Math.cos(rotationAngle) - dz * Math.sin(rotationAngle);
                                const rotatedZ = dx * Math.sin(rotationAngle) + dz * Math.cos(rotationAngle);

                                finalX = centerX + rotatedX * spreadFactor;
                                finalY = centerY + dy * spreadFactor;
                                finalZ = centerZ + rotatedZ * spreadFactor;
                            } else {
                                const time = clusterAnimationTime * 1000 * subParticleAnimationSpeed;
                                const orbitPhase = subParticle.orbitPhase;
                                const orbitRadius = subParticleMotionSpeed * 2.0;

                                let orbitX, orbitY, orbitZ;

                                if (subParticleMotionPath === 'sphere') {
                                    // 3D spherical orbit
                                    const theta = time + orbitPhase;
                                    const phi = time * 0.7 + orbitPhase * 1.3;
                                    orbitX = Math.sin(phi) * Math.cos(theta) * orbitRadius;
                                    orbitY = Math.sin(phi) * Math.sin(theta) * orbitRadius;
                                    orbitZ = Math.cos(phi) * orbitRadius;
                                } else if (subParticleMotionPath === 'figure8') {
                                    // Figure-eight (lemniscate) pattern
                                    const t = time + orbitPhase;
                                    const scale = orbitRadius * 1.5;
                                    orbitX = (Math.sin(t) * scale) / (1 + Math.cos(t) * Math.cos(t));
                                    orbitY = (Math.sin(t) * Math.cos(t) * scale) / (1 + Math.cos(t) * Math.cos(t));
                                    orbitZ = 0;
                                } else if (subParticleMotionPath === 'random') {
                                    // Random - Each particle has unique rotation axis and speed
                                    const angle = time * subParticle.randomOrbitSpeed + orbitPhase;
                                    const axis = subParticle.randomOrbitAxis;

                                    // Rotate around random axis using Rodrigues' rotation formula
                                    const dx = subParticle.offset.x;
                                    const dy = subParticle.offset.y;
                                    const dz = subParticle.offset.z;

                                    const cosA = Math.cos(angle);
                                    const sinA = Math.sin(angle);
                                    const dot = axis.x * dx + axis.y * dy + axis.z * dz;

                                    orbitX = dx * cosA + (axis.y * dz - axis.z * dy) * sinA + axis.x * dot * (1 - cosA);
                                    orbitY = dy * cosA + (axis.z * dx - axis.x * dz) * sinA + axis.y * dot * (1 - cosA);
                                    orbitZ = dz * cosA + (axis.x * dy - axis.y * dx) * sinA + axis.z * dot * (1 - cosA);

                                    orbitX *= orbitRadius * 0.5;
                                    orbitY *= orbitRadius * 0.5;
                                    orbitZ *= orbitRadius * 0.5;
                                } else {
                                    // Ring (2D orbit) - default
                                    orbitX = Math.sin(time + orbitPhase) * orbitRadius;
                                    orbitZ = Math.cos(time + orbitPhase) * orbitRadius;
                                    orbitY = Math.sin(time * 0.8 + orbitPhase * 0.7) * (orbitRadius * 0.3);
                                }

                                finalX = baseX + orbitX;
                                finalY = baseY + orbitY;
                                finalZ = baseZ + orbitZ;
                            }
                        }

                        // Update instance matrix
                        dummy.position.set(finalX, finalY, finalZ);

                        // Check if this category is hidden OR if search is active and file doesn't match OR if tag filter is active and file doesn't match
                        const fileCategory = getCategoryForFile(cluster.file);
                        const isHiddenByCategory = hiddenCategories.has(fileCategory);
                        const isHiddenBySearch = searchFilteredFileIds.size > 0 && !searchFilteredFileIds.has(cluster.file.id);
                        const isHiddenByTagFilter = tagFilteredFileIds.size > 0 && !tagFilteredFileIds.has(cluster.file.id);
                        const isHidden = isHiddenByCategory || isHiddenBySearch || isHiddenByTagFilter;

                        // Scale - center particles are larger based on ratio
                        let scale = isHidden ? 0 : particleSize * subParticleScale;
                        if (!isHidden && subParticle.isCenterParticle) {
                            scale *= mainToSubSizeRatio;
                        }

                        // Apply size gradient: center = full size, outer = smaller
                        if (!isHidden && sizeGradient > 0 && !subParticle.isCenterParticle) {
                            // At max gradient (2.0), outer particles can shrink to near-zero
                            const gradientFactor = Math.max(0.05, 1.0 - (subParticle.distanceFromCenter * sizeGradient * 0.8));
                            scale *= gradientFactor;
                        }

                        // Audio reactivity for particle pulsing
                        if (!isHidden && audioReactivityEnabled && currentAudioAmplitude > 0) {
                            if (isPlayingCluster) {
                                // Currently playing cluster pulses strongly
                                scale *= (1.0 + currentAudioAmplitude * (audioReactivityStrength * 0.1));
                            } else if (globalAudioReactivity > 0) {
                                // Other clusters pulse subtly based on global setting
                                scale *= (1.0 + currentAudioAmplitude * (globalAudioReactivity * 0.05));
                            }
                        }

                        // Apply hover scale effect
                        if (!isHidden && isHovered && mouseInteractionEnabled && hoverScale > 1.0) {
                            scale *= hoverScale;
                        }

                        dummy.scale.setScalar(scale);
                        dummy.lookAt(camera.position);
                        dummy.updateMatrix();
                        particleSystem.setMatrixAt(subParticle.instanceIndex, dummy.matrix);
                    });
                });
                particleSystem.instanceMatrix.needsUpdate = true;
            }


            // Update raycasting for targeting
            updateTargeting();

            // Update bloom strength
            if (bloomPass) {
                bloomPass.strength = bloomStrength; // Direct 0-10 range
            }

            // Render with or without bloom
            if (bloomStrength > 0 && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // 6DOF movement (W/S follows camera direction fully, including up/down)
        function updateMovement() {
            // Smooth interpolation for look joystick (mobile only)
            if (isMobileDevice) {
                yaw += (targetYaw - yaw) * lookSmoothingFactor;
                pitch += (targetPitch - pitch) * lookSmoothingFactor;
            }

            // Update camera rotation from yaw/pitch (for mobile and desktop)
            // On desktop: yaw/pitch updated by onMouseMove when pointer locked
            // On mobile: yaw/pitch updated by setupSwipeToLook touch handlers
            if (isMobileDevice || isPointerLocked) {
                camera.rotation.order = 'YXZ';
                camera.rotation.y = yaw;
                camera.rotation.x = pitch;
            }

            const direction = new THREE.Vector3();

            // Calculate direction based on camera rotation (full 3D direction)
            const forward = new THREE.Vector3(0, 0, -1);
            const right = new THREE.Vector3(1, 0, 0);

            // Apply camera rotation to get true forward and right vectors
            forward.applyQuaternion(camera.quaternion);
            right.applyQuaternion(camera.quaternion);

            // Apply movement keys - W/S now follows camera direction including vertical!
            if (keys['w'] || keys['W'] || keys['ArrowUp']) direction.add(forward);
            if (keys['s'] || keys['S'] || keys['ArrowDown']) direction.sub(forward);
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) direction.sub(right);
            if (keys['d'] || keys['D'] || keys['ArrowRight']) direction.add(right);

            direction.normalize();

            // Apply sprint multiplier if shift is held
            let currentSpeed = moveSpeed;
            if (isShiftPressed) {
                currentSpeed *= 3; // 3x speed when sprinting
            }

            // Scale speed by joystick intensity on mobile (0-1 range)
            if (isMobileDevice && joystickIntensity > 0) {
                currentSpeed *= joystickIntensity;
            }

            camera.position.add(direction.multiplyScalar(currentSpeed));
        }

        // Update targeting (center of screen)
        function updateTargeting() {
            if (!particleSystem) return;

            // Cast ray from center of screen
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObject(particleSystem);

            if (intersects.length > 0) {
                const instanceId = intersects[0].instanceId;

                // Find which cluster this sub-particle belongs to
                let targetedCluster = null;
                for (const cluster of particles) {
                    for (const subParticle of cluster.subParticles) {
                        if (subParticle.instanceIndex === instanceId) {
                            targetedCluster = cluster;
                            break;
                        }
                    }
                    if (targetedCluster) break;
                }

                if (targetedCluster) {
                    document.getElementById('targetedFile').textContent = targetedCluster.file.name.substring(0, 20) + '...';

                    // Show tooltip at center
                    showFileTooltip(targetedCluster);
                    document.body.style.cursor = 'pointer';

                    // Set hovered cluster for visual effects
                    if (mouseInteractionEnabled) {
                        hoveredCluster = targetedCluster;
                    } else {
                        hoveredCluster = null;
                    }
                } else {
                    document.getElementById('targetedFile').textContent = 'None';
                    hideFileTooltip();
                    document.body.style.cursor = 'default';
                    hoveredCluster = null;
                }
            } else {
                document.getElementById('targetedFile').textContent = 'None';
                hideFileTooltip();
                document.body.style.cursor = 'default';
                hoveredCluster = null;
            }
        }

        // Show file tooltip
        function showFileTooltip(particle) {
            if (!tooltipsEnabled) return; // Respect tooltip toggle

            const tooltip = document.getElementById('fileTooltip');
            const tooltipTitle = document.getElementById('tooltipTitle');
            const tooltipMetadata = document.getElementById('tooltipMetadata');
            const tooltipTags = document.getElementById('tooltipTags');

            tooltipTitle.textContent = particle.file.name;

            let metadata = '';
            if (particle.file.id) {
                // Strip "audio_files_" prefix if present
                const cleanId = particle.file.id.replace(/^audio_files_/, '');
                metadata += `ID: ${cleanId}`;
            }
            if (particle.file.bpm) metadata += (metadata ? ' • ' : '') + `${particle.file.bpm} BPM`;
            if (particle.file.key) metadata += (metadata ? ' • ' : '') + particle.file.key;
            tooltipMetadata.textContent = metadata;

            // Tags
            tooltipTags.innerHTML = '';
            if (particle.file.tags && particle.file.tags.length > 0) {
                particle.file.tags.forEach(tag => {
                    const chip = document.createElement('div');
                    chip.className = 'tag-chip';
                    chip.textContent = tag;
                    tooltipTags.appendChild(chip);
                });
            }

            tooltip.classList.add('active');
            // Position at center-right
            tooltip.style.left = '55%';
            tooltip.style.top = '50%';
            tooltip.style.transform = 'translateY(-50%)';
        }

        // Hide file tooltip
        function hideFileTooltip() {
            document.getElementById('fileTooltip').classList.remove('active');
        }

        // Mouse move (for pointer locked mode)
        function onMouseMove(event) {
            if (isPointerLocked) {
                const movementX = event.movementX || 0;
                const movementY = event.movementY || 0;

                yaw -= movementX * 0.002;
                pitch -= movementY * 0.002;

                // Limit pitch to prevent flipping
                pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));

                // Camera rotation applied in updateMovement()
            } else {
                // Track mouse position for particle interaction when not locked
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                // Project mouse to 3D space at a fixed distance from camera
                mouse3D.set(mouse.x, mouse.y, 0.5);
                mouse3D.unproject(camera);

                // Get world position at a distance from camera
                const dir = mouse3D.sub(camera.position).normalize();
                const distance = 30; // Distance in front of camera
                mouseWorldPos.copy(camera.position).add(dir.multiplyScalar(distance));
            }
        }

        // Click handler - play file or create ripple
        function onClick(event) {
            if (!particleSystem) return;

            // Ignore clicks on UI elements (buttons, controls, player, etc.)
            if (event.target.tagName !== 'CANVAS' && event.target.id !== 'canvas-container') {
                return;
            }

            // If pointer is not locked and not on mobile, this click is just to re-enter pointer lock
            // Don't trigger file selection (but allow on mobile where pointer lock doesn't exist)
            if (!isPointerLocked && !isMobileDevice) {
                return;
            }

            // Calculate click/tap position
            let clickX, clickY;
            if (event.tapX !== undefined && event.tapY !== undefined) {
                // Mobile tap with coordinates
                clickX = (event.tapX / window.innerWidth) * 2 - 1;
                clickY = -(event.tapY / window.innerHeight) * 2 + 1;
            } else if (isMobileDevice) {
                // Mobile but no tap coords, use center (crosshair)
                clickX = 0;
                clickY = 0;
            } else {
                // Desktop pointer locked mode - always center (crosshair)
                clickX = 0;
                clickY = 0;
            }

            raycaster.setFromCamera(new THREE.Vector2(clickX, clickY), camera);
            const intersects = raycaster.intersectObject(particleSystem);

            if (intersects.length > 0) {
                const instanceId = intersects[0].instanceId;

                // Find which cluster this sub-particle belongs to
                let clickedCluster = null;
                for (const cluster of particles) {
                    for (const subParticle of cluster.subParticles) {
                        if (subParticle.instanceIndex === instanceId) {
                            clickedCluster = cluster;
                            break;
                        }
                    }
                    if (clickedCluster) break;
                }

                if (clickedCluster) {
                    loadAndPlayFile(clickedCluster.file);
                }
            }
        }

        // Stop and clean up multi-stem players
        function stopMultiStem() {
            stemWavesurfers.forEach(ws => {
                if (ws) {
                    ws.pause();
                    ws.stop();
                    ws.destroy();
                }
            });
            stemWavesurfers = [];
            currentPlayingStems = [];

            // Hide multi-stem player and remove body class
            const multiStemPlayer = document.getElementById('multiStemPlayer');
            if (multiStemPlayer) {
                multiStemPlayer.style.display = 'none';
            }

            // Hide stem expand button
            const stemExpandBtn = document.getElementById('stemExpandBtn');
            if (stemExpandBtn) {
                stemExpandBtn.style.display = 'none';
            }

            document.body.classList.remove('multi-stem-active');
            document.body.style.setProperty('--multi-stem-height', '0px');
        }

        // Toggle multi-stem player expanded/collapsed
        function toggleMultiStemExpanded() {
            const header = document.querySelector('.multi-stem-header');
            const content = document.getElementById('multiStemContent');
            const icon = document.getElementById('multiStemExpandIcon');

            header.classList.toggle('collapsed');
            content.classList.toggle('collapsed');
            icon.textContent = header.classList.contains('collapsed') ? '▶' : '▼';

            // Update height after toggle
            setTimeout(() => {
                const multiStemPlayer = document.getElementById('multiStemPlayer');
                const height = multiStemPlayer.offsetHeight;
                document.body.style.setProperty('--multi-stem-height', `${height}px`);
            }, 50);
        }

        // Toggle multi-stem player visibility (T key - "Tracks")
        function toggleMultiStemPlayer() {
            const multiStemPlayer = document.getElementById('multiStemPlayer');
            if (!multiStemPlayer) return;

            if (multiStemPlayer.style.display === 'none') {
                multiStemPlayer.style.display = 'flex';
                isMultiStemPlayerVisible = true;
                document.body.classList.add('multi-stem-active');
                setTimeout(() => {
                    const height = multiStemPlayer.offsetHeight;
                    document.body.style.setProperty('--multi-stem-height', `${height}px`);
                }, 50);
            } else {
                multiStemPlayer.style.display = 'none';
                isMultiStemPlayerVisible = false;
                document.body.classList.remove('multi-stem-active');
                document.body.style.setProperty('--multi-stem-height', '0px');
            }
        }

        // Toggle mute for individual stem
        function toggleStemMute(index) {
            const ws = stemWavesurfers[index];
            if (!ws) return;

            const btn = document.getElementById(`stemMuteBtn${index}`);
            const volumeSlider = document.getElementById(`stemVolume${index}`);
            const currentVolume = ws.getVolume();

            if (currentVolume > 0) {
                // Mute
                ws.setVolume(0);
                ws._savedVolume = currentVolume;
                btn.classList.add('active');
                const icon = btn.querySelector('span');
                if (icon) icon.textContent = '🔇';
                if (volumeSlider) volumeSlider.value = 0;
                setStemVolume(index, 0);
            } else {
                // Unmute
                const restored = ws._savedVolume || 1;
                ws.setVolume(restored);
                btn.classList.remove('active');
                const icon = btn.querySelector('span');
                if (icon) icon.textContent = '🔊';
                if (volumeSlider) volumeSlider.value = restored * 100;
                setStemVolume(index, restored * 100);
            }
        }

        // Set volume for individual stem
        function setStemVolume(index, value) {
            const ws = stemWavesurfers[index];
            if (!ws) return;

            const volume = value / 100;
            ws.setVolume(volume);

            // Update volume percentage display
            const percentElem = document.getElementById(`stemVolumePercent${index}`);
            if (percentElem) {
                percentElem.textContent = `${value}%`;
            }

            // Update mute button icon
            const btn = document.getElementById(`stemMuteBtn${index}`);
            if (btn) {
                const icon = btn.querySelector('span');
                if (icon) {
                    icon.textContent = volume === 0 ? '🔇' : '🔊';
                }
                if (volume === 0) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
        }

        // Toggle play/pause for individual stem
        function toggleStemPlayPause(index) {
            const ws = stemWavesurfers[index];
            if (!ws) return;

            const icon = document.getElementById(`stemPlayPauseIcon${index}`);

            if (ws.isPlaying()) {
                ws.pause();
                if (icon) icon.textContent = '▶';
            } else {
                ws.play();
                if (icon) icon.textContent = '||';
            }
        }

        // Toggle loop for individual stem
        function toggleStemLoop(index) {
            const ws = stemWavesurfers[index];
            if (!ws) return;

            const btn = document.getElementById(`stemLoopBtn${index}`);

            // Toggle loop state stored on wavesurfer instance
            ws._looping = !ws._looping;

            if (ws._looping) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }

        // Load and play multiple stems from same parent song
        function loadAndPlayMultiStem(clickedStem) {
            console.log('=== V26 MULTI-STEM PLAYBACK START ===');
            console.log('Multi-stem playback triggered for:', clickedStem.name);
            console.log('Clicked stem audio_file_id:', clickedStem.audio_file_id);

            // Clean up existing players
            stopMultiStem();

            isMultiStemMode = true;

            // Find all stems with same audio_file_id
            const parentId = clickedStem.audio_file_id;
            const allStems = audioFiles.filter(f =>
                f._source === 'audio_files_stems' &&
                f.audio_file_id === parentId
            );

            console.log(`Found ${allStems.length} stems for parent ID ${parentId}`);
            currentPlayingStems = allStems;

            // Find the parent file - try both ID formats
            console.log('=== SEARCHING FOR PARENT FILE ===');
            console.log('Parent ID to search for:', parentId);
            console.log('Searching for ID:', `audio_files_${parentId}`);
            console.log('Total audioFiles loaded:', audioFiles.length);
            console.log('audio_files count:', audioFiles.filter(f => f._source === 'audio_files').length);
            console.log('audio_files_stems count:', audioFiles.filter(f => f._source === 'audio_files_stems').length);

            let parentFile = audioFiles.find(f =>
                f._source === 'audio_files' &&
                f.id === `audio_files_${parentId}`
            );

            console.log('First search result:', parentFile);

            // If not found, try without prefix (in case ID doesn't have prefix)
            if (!parentFile) {
                console.log('First search failed, trying alternate ID format...');
                parentFile = audioFiles.find(f =>
                    f._source === 'audio_files' &&
                    parseInt(f.id) === parseInt(parentId)
                );
                console.log('Second search result:', parentFile);
            }

            // If still not found, show all audio_files IDs for debugging
            if (!parentFile) {
                console.log('PARENT FILE NOT FOUND!');
                console.log('All audio_files IDs:', audioFiles.filter(f => f._source === 'audio_files').map(f => f.id));
            }

            console.log('Final parent file:', parentFile);

            // Load parent file in main player (muted, for master control)
            if (wavesurfer) {
                wavesurfer.pause();
                wavesurfer.stop();
                wavesurfer.destroy();
            }

            wavesurfer = WaveSurfer.create({
                container: '#waveform',
                waveColor: '#666',
                progressColor: '#667eea',
                cursorColor: '#ffffff',
                barWidth: 3,
                barRadius: 3,
                cursorWidth: 2,
                height: 60,
                barGap: 2,
                responsive: true,
                normalize: true,
                backend: 'WebAudio',
                interact: true,
                hideScrollbar: true
            });

            if (parentFile && parentFile.file_url) {
                console.log('Loading parent file for master control:', parentFile.name, parentFile.file_url);

                // Update UI with parent file info
                document.getElementById('playerFilename').textContent = parentFile.name;

                let metadata = '';
                if (parentFile.bpm) metadata += `${parentFile.bpm} BPM`;
                if (parentFile.key) metadata += (metadata ? ' • ' : '') + parentFile.key;
                if (parentFile.tags && parentFile.tags.length > 0) metadata += (metadata ? ' • ' : '') + parentFile.tags.slice(0, 3).join(', ');
                metadata += (metadata ? ' • ' : '') + `${allStems.length} stems`;
                document.getElementById('playerMetadata').textContent = metadata;

                wavesurfer.load(parentFile.file_url);
            } else {
                console.warn('Parent file not found! Using clicked stem info instead.');

                // Fallback to clicked stem info
                document.getElementById('playerFilename').textContent = clickedStem.name;

                let metadata = '';
                if (clickedStem.bpm) metadata += `${clickedStem.bpm} BPM`;
                if (clickedStem.key) metadata += (metadata ? ' • ' : '') + clickedStem.key;
                metadata += (metadata ? ' • ' : '') + `${allStems.length} stems`;
                document.getElementById('playerMetadata').textContent = metadata;
            }

            // Show multi-stem player and build UI
            const multiStemPlayer = document.getElementById('multiStemPlayer');
            multiStemPlayer.innerHTML = ''; // Clear previous content

            // Show stem expand button in main player (highlighted when collapsed)
            const stemExpandBtn = document.getElementById('stemExpandBtn');
            if (stemExpandBtn) {
                stemExpandBtn.style.display = 'inline-block';
                // Start collapsed, so highlight the button
                if (!stemPlayerExpanded) {
                    stemExpandBtn.style.background = 'rgba(102,126,234,0.3)';
                    stemExpandBtn.style.border = '1px solid #667eea';
                }
            }

            // Only show if user hasn't toggled it off with T key
            if (isMultiStemPlayerVisible) {
                multiStemPlayer.style.display = 'flex';
                // Add class to body and set height variable for pushing other elements
                document.body.classList.add('multi-stem-active');
                // Make sure it's expanded by default
                if (!stemPlayerExpanded) {
                    multiStemPlayer.classList.add('collapsed');
                }
            } else {
                multiStemPlayer.style.display = 'none';
            }

            // Update height after content loads (only if expanded)
            setTimeout(() => {
                if (stemPlayerExpanded) {
                    const height = multiStemPlayer.offsetHeight;
                    document.body.style.setProperty('--multi-stem-height', `${height}px`);
                } else {
                    // If collapsed, set height to 0
                    document.body.style.setProperty('--multi-stem-height', '0px');
                    document.body.classList.remove('multi-stem-active');
                }
            }, 100);

            // Create a WaveSurfer instance for each stem
            let readyCount = 0;

            allStems.forEach((stem, index) => {
                // Create a full player bar for this stem (similar to bottom player)
                const stemPlayerBar = document.createElement('div');
                stemPlayerBar.className = 'stem-player-bar';
                stemPlayerBar.innerHTML = `
                    <div class="stem-player-controls">
                        <button class="stem-player-btn play-pause" onclick="toggleStemPlayPause(${index})" id="stemPlayPauseBtn${index}">
                            <span id="stemPlayPauseIcon${index}">||</span>
                        </button>
                        <button class="stem-player-btn" onclick="toggleStemMute(${index})" id="stemMuteBtn${index}" title="Mute">
                            <span>🔊</span>
                        </button>
                        <button class="stem-player-btn" onclick="toggleStemLoop(${index})" id="stemLoopBtn${index}" title="Loop">
                            <span>LOOP</span>
                        </button>
                    </div>

                    <div class="stem-player-waveform" id="stemWaveform${index}"></div>

                    <div class="stem-player-info">
                        <div class="stem-player-filename">${stem.name.length > 30 ? stem.name.substring(0, 30) + '...' : stem.name}</div>
                        <div class="stem-player-time" id="stemTime${index}">0:00 / 0:00</div>
                    </div>

                    <div class="stem-player-volume">
                        <span>🔊</span>
                        <input type="range" min="0" max="100" value="100"
                               oninput="setStemVolume(${index}, this.value)" id="stemVolume${index}">
                        <span id="stemVolumePercent${index}">100%</span>
                    </div>
                `;
                multiStemPlayer.appendChild(stemPlayerBar);

                // Wait for DOM to update before creating WaveSurfer
                setTimeout(() => {
                    // Create WaveSurfer for this stem
                    const ws = WaveSurfer.create({
                        container: `#stemWaveform${index}`,
                        waveColor: '#555',
                        progressColor: '#667eea',
                        cursorColor: '#ffffff',
                        barWidth: 2,
                        barRadius: 2,
                        cursorWidth: 1,
                        height: 50,
                        barGap: 1,
                        responsive: true,
                        normalize: true,
                        backend: 'WebAudio',
                        interact: true,
                        hideScrollbar: true
                    });

                    ws._stemFile = stem; // Store reference to stem file
                    ws._stemIndex = index; // Store index

                    // Log file info for debugging with actual HTTP header check
                    const logFileInfo = async () => {
                        console.log(`\nLoading stem ${index + 1}: ${stem.name}`);
                        console.log(`  Database file_size: ${stem.file_size ? (stem.file_size / (1024 * 1024)).toFixed(2) + ' MB' : 'not set'}`);
                        console.log(`  File URL: ${stem.file_url}`);

                        try {
                            const response = await fetch(stem.file_url, { method: 'HEAD' });
                            const contentLength = response.headers.get('content-length');
                            const contentType = response.headers.get('content-type');

                            if (contentLength) {
                                const sizeMB = (contentLength / (1024 * 1024)).toFixed(2);
                                console.log(`  ACTUAL file size: ${sizeMB} MB (${contentLength} bytes)`);
                            }
                            if (contentType) {
                                console.log(`  Content-Type: ${contentType}`);
                            }
                        } catch (e) {
                            console.log(`  Could not fetch headers: ${e.message}`);
                        }
                    };

                    logFileInfo();
                    ws.load(stem.file_url);

                    ws.once('ready', () => {
                        readyCount++;
                        console.log(`Stem ${index + 1}/${allStems.length} ready: ${stem.name}`);

                        // Apply current main volume slider value to this stem
                        const mainVolume = document.getElementById('volumeSlider').value;
                        ws.setVolume(mainVolume / 100);

                        // When all stems are ready, play them all in sync
                        if (readyCount === allStems.length) {
                            console.log('All stems ready - starting synchronized playback');
                            currentFileId = clickedStem.id; // Set to clicked stem's ID

                            // Play all stems simultaneously
                            stemWavesurfers.forEach((w, i) => {
                                w.play();
                                const icon = document.getElementById(`stemPlayPauseIcon${i}`);
                                if (icon) icon.textContent = '||';
                            });
                            document.getElementById('playPauseIcon').textContent = '||';
                            updatePlayButtonIcon();

                            // Set up audio analysis for the first stem (for visualization)
                            setupAudioAnalysis();
                        }
                    });

                    // Update time display during playback
                    ws.on('audioprocess', () => {
                        const current = ws.getCurrentTime();
                        const duration = ws.getDuration();
                        const timeElem = document.getElementById(`stemTime${index}`);
                        if (timeElem) {
                            timeElem.textContent = `${formatTime(current)} / ${formatTime(duration)}`;
                        }
                    });

                    // Handle individual stem finish (for per-stem looping)
                    ws.on('finish', () => {
                        const icon = document.getElementById(`stemPlayPauseIcon${index}`);
                        if (icon) icon.textContent = '▶';

                        if (ws._looping) {
                            ws.seekTo(0);
                            ws.play();
                            if (icon) icon.textContent = '||';
                        }
                    });

                    stemWavesurfers.push(ws);
                }, 10); // Small delay to ensure DOM is ready
            });

            // Handle finish event - loop all stems together
            stemWavesurfers[0]?.on('finish', () => {
                if (isLooping) {
                    stemWavesurfers.forEach(ws => {
                        ws.seekTo(0);
                        ws.play();
                    });
                } else if (isShuffling) {
                    playRandomFile();
                } else {
                    playNextTrack();
                }
            });

            // Set up master waveform control (parent file plays muted alongside stems)
            wavesurfer.once('ready', () => {
                console.log('Master waveform ready (parent file)');
                console.log('Master duration:', wavesurfer.getDuration());

                // Mute the master waveform by default (we only want stems to be heard)
                wavesurfer.setVolume(0);

                // When user clicks/seeks on master waveform, seek all stems
                wavesurfer.on('interaction', () => {
                    const seekPosition = wavesurfer.getCurrentTime() / wavesurfer.getDuration();
                    console.log('Master seek to:', seekPosition);

                    // Seek all stems to match
                    stemWavesurfers.forEach(ws => {
                        ws.seekTo(seekPosition);
                    });

                    // If stems are playing, make sure master is also playing
                    if (stemWavesurfers[0] && stemWavesurfers[0].isPlaying()) {
                        wavesurfer.play();
                    }
                });

                // When stems start playing, play master too (muted)
                if (stemWavesurfers[0]) {
                    // Play master when first stem plays
                    stemWavesurfers[0].on('play', () => {
                        if (!wavesurfer.isPlaying()) {
                            wavesurfer.play();
                        }
                    });

                    // Pause master when first stem pauses
                    stemWavesurfers[0].on('pause', () => {
                        if (wavesurfer.isPlaying()) {
                            wavesurfer.pause();
                        }
                    });

                    // Keep master in sync with stems
                    stemWavesurfers[0].on('audioprocess', () => {
                        // Sync master position with first stem
                        const stemPosition = stemWavesurfers[0].getCurrentTime() / stemWavesurfers[0].getDuration();
                        const masterPosition = wavesurfer.getCurrentTime() / wavesurfer.getDuration();

                        // Only sync if they're more than 0.1 second apart
                        if (Math.abs(stemPosition - masterPosition) > 0.01) {
                            wavesurfer.seekTo(stemPosition);
                        }
                    });
                }

                // Update time display from master wavesurfer
                wavesurfer.on('audioprocess', () => {
                    const current = wavesurfer.getCurrentTime();
                    const duration = wavesurfer.getDuration();
                    document.getElementById('playerTime').textContent =
                        `${formatTime(current)} / ${formatTime(duration)}`;
                });
            });
        }

        // Load and play audio file
        function loadAndPlayFile(file) {
            // Check if this is a stem - if so, load all stems from same parent
            if (file._source === 'audio_files_stems' && file.audio_file_id) {
                loadAndPlayMultiStem(file);
                return;
            }

            // Regular single-file playback
            isMultiStemMode = false;

            // Clean up any existing multi-stem players
            stopMultiStem();

            // Initialize or reinitialize wavesurfer
            if (wavesurfer) {
                wavesurfer.pause();
                wavesurfer.stop();
                wavesurfer.destroy();
            }

            wavesurfer = WaveSurfer.create({
                container: '#waveform',
                waveColor: '#666',
                progressColor: '#667eea',
                cursorColor: '#ffffff',
                barWidth: 3,
                barRadius: 3,
                cursorWidth: 2,
                height: 60,
                barGap: 2,
                responsive: true,
                normalize: true,
                backend: 'WebAudio',
                interact: true,
                hideScrollbar: true
            });

            wavesurfer.load(file.file_url);

            // Update UI
            document.getElementById('playerFilename').textContent = file.name;

            // Update mini player info (mobile)
            const miniInfo = document.getElementById('playerMiniInfo');
            if (miniInfo) {
                miniInfo.textContent = file.name.length > 30 ? file.name.substring(0, 30) + '...' : file.name;
            }

            let metadata = '';
            if (file.bpm) metadata += `${file.bpm} BPM`;
            if (file.key) metadata += (metadata ? ' • ' : '') + file.key;
            if (file.tags && file.tags.length > 0) metadata += (metadata ? ' • ' : '') + file.tags.slice(0, 3).join(', ');
            document.getElementById('playerMetadata').textContent = metadata;

            document.getElementById('playerTime').textContent = '0:00 / 0:00';
            document.getElementById('playPauseIcon').textContent = '▶';
            const miniIcon = document.getElementById('miniPlayPauseIcon');
            if (miniIcon) miniIcon.textContent = '▶';
            updatePlayButtonIcon();

            // Don't auto-show player - let user control visibility with P or H keys

            // Auto-play when ready
            wavesurfer.once('ready', () => {
                // Set up audio analysis for reactivity
                setupAudioAnalysis();

                // Set currentFileId only when audio actually starts playing
                currentFileId = file.id;

                // Update navigation category if in COLOR mode
                if (navMode === 'color') {
                    currentNavCategory = getCategoryForFile(file);
                    console.log(`Switched to category: ${currentNavCategory}`);
                }

                // Enhanced auto-play with better error handling
                const attemptAutoPlay = () => {
                    // Check and resume audio context if suspended
                    if (wavesurfer.backend && wavesurfer.backend.ac) {
                        const audioContext = wavesurfer.backend.ac;
                        console.log('Audio context state:', audioContext.state);

                        if (audioContext.state === 'suspended') {
                            console.log('Audio context suspended, attempting to resume...');
                            audioContext.resume().then(() => {
                                console.log('Audio context resumed successfully');
                            }).catch(err => {
                                console.log('Failed to resume audio context:', err);
                            });
                        }
                    }

                    // Log wavesurfer state for debugging
                    console.log('Wavesurfer state:', {
                        isReady: wavesurfer.isReady,
                        duration: wavesurfer.getDuration(),
                        hasBackend: !!wavesurfer.backend
                    });

                    // Longer initial delay for better reliability (300ms instead of 50ms)
                    setTimeout(() => {
                        const playPromise = wavesurfer.play();
                        if (playPromise !== undefined) {
                            playPromise.then(() => {
                                // Verify playback started with longer delay (400ms instead of 200ms)
                                setTimeout(() => {
                                    if (wavesurfer.isPlaying()) {
                                        // Success!
                                        document.getElementById('playPauseIcon').textContent = '||';
                                        const miniIcon = document.getElementById('miniPlayPauseIcon');
                                        if (miniIcon) miniIcon.textContent = '||';
                                        updatePlayButtonIcon();
                                        console.log('Auto-play successful');
                                    } else {
                                        // Retry with longer delays
                                        console.log('Play promise resolved but not playing, starting retry sequence...');

                                        let retryCount = 0;
                                        const maxRetries = 5; // Increased from 3

                                        const retryPlay = () => {
                                            console.log(`Retry attempt ${retryCount + 1}/${maxRetries}`);

                                            // Check audio context again before retry
                                            if (wavesurfer.backend && wavesurfer.backend.ac && wavesurfer.backend.ac.state === 'suspended') {
                                                wavesurfer.backend.ac.resume();
                                            }

                                            wavesurfer.play().then(() => {
                                                // Longer verification delay for retries (300ms)
                                                setTimeout(() => {
                                                    if (wavesurfer.isPlaying()) {
                                                        document.getElementById('playPauseIcon').textContent = '||';
                                                        const miniIcon = document.getElementById('miniPlayPauseIcon');
                                                        if (miniIcon) miniIcon.textContent = '||';
                                                        updatePlayButtonIcon();
                                                        console.log(`✓ Playback started after ${retryCount + 1} retries`);
                                                    } else if (retryCount < maxRetries - 1) {
                                                        retryCount++;
                                                        // Longer delay between retries (500ms instead of 150ms)
                                                        setTimeout(retryPlay, 500);
                                                    } else {
                                                        console.log('✗ All retries exhausted, auto-play failed');
                                                        document.getElementById('playPauseIcon').textContent = '▶';
                                                        const miniIcon = document.getElementById('miniPlayPauseIcon');
                                                        if (miniIcon) miniIcon.textContent = '▶';
                                                        updatePlayButtonIcon();
                                                    }
                                                }, 300);
                                            }).catch(e => {
                                                console.log(`Retry ${retryCount + 1} failed:`, e);
                                                if (retryCount < maxRetries - 1) {
                                                    retryCount++;
                                                    setTimeout(retryPlay, 500);
                                                }
                                            });
                                        };

                                        retryPlay();
                                    }
                                }, 400);
                            }).catch(error => {
                                // Autoplay was prevented by browser
                                console.log('Autoplay prevented by browser policy:', error);
                                document.getElementById('playPauseIcon').textContent = '▶';
                                const miniIcon = document.getElementById('miniPlayPauseIcon');
                                if (miniIcon) miniIcon.textContent = '▶';
                                updatePlayButtonIcon();
                            });
                        }
                    }, 300);
                };

                attemptAutoPlay();
                updatePlayerTime();
            });

            wavesurfer.on('audioprocess', updatePlayerTime);
            wavesurfer.on('seeking', updatePlayerTime);
            wavesurfer.on('finish', () => {
                if (isLooping) {
                    // Explicitly seek to beginning before playing again
                    wavesurfer.seekTo(0);
                    const playPromise = wavesurfer.play();
                    if (playPromise !== undefined) {
                        playPromise.catch(e => console.log('Loop play prevented:', e));
                    }
                } else if (isShuffling) {
                    playRandomFile();
                } else {
                    // Auto-play next track in order
                    playNextTrack();
                }
            });

            // Apply current volume
            const currentVolume = document.getElementById('volumeSlider').value;
            wavesurfer.setVolume(currentVolume / 100);
        }

        // Set up audio analysis for particle reactivity
        function setupAudioAnalysis() {
            // In multi-stem mode, use the first stem's wavesurfer
            // In regular mode, use the main wavesurfer
            const targetWavesurfer = isMultiStemMode && stemWavesurfers.length > 0
                ? stemWavesurfers[0]
                : wavesurfer;

            if (!targetWavesurfer) return;

            try {
                // WaveSurfer v7 WebAudio backend - access internal nodes
                setTimeout(() => {
                    const mediaElement = targetWavesurfer.getMediaElement();

                    if (!mediaElement) {
                        console.error('No media element found');
                        return;
                    }

                    console.log('Media element object:', mediaElement);

                    // Access WaveSurfer's audio context and gain node
                    audioContext = mediaElement.audioContext;
                    const gainNode = mediaElement.gainNode;

                    if (!audioContext || !gainNode) {
                        console.error('Could not access audioContext or gainNode');
                        return;
                    }

                    console.log('Audio context:', audioContext);
                    console.log('Gain node:', gainNode);

                    // Create analyser
                    analyser = audioContext.createAnalyser();
                    analyser.fftSize = 512;
                    analyser.smoothingTimeConstant = 0.8;
                    analyser.minDecibels = -90;
                    analyser.maxDecibels = -10;

                    // Insert analyser into WaveSurfer's audio chain
                    // Disconnect gain from destination, route through analyser
                    gainNode.disconnect();
                    gainNode.connect(analyser);
                    analyser.connect(audioContext.destination);

                    // Prepare data array
                    const bufferLength = analyser.frequencyBinCount;
                    audioDataArray = new Uint8Array(bufferLength);

                    console.log('✓ Audio analysis setup complete', {
                        fftSize: analyser.fftSize,
                        bufferLength: bufferLength,
                        contextState: audioContext.state
                    });

                    // Resume context if suspended
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                }, 100);

            } catch (error) {
                console.error('Error setting up audio analysis:', error);
            }
        }

        // Update audio amplitude from analyser
        function updateAudioAmplitude() {
            if (!analyser || !audioDataArray) {
                currentAudioAmplitude = 0;
                bassAmplitude = 0;
                midsAmplitude = 0;
                highsAmplitude = 0;
                return;
            }

            // Get frequency data
            analyser.getByteFrequencyData(audioDataArray);

            // Calculate frequency ranges based on sample rate
            const bufferLength = analyser.frequencyBinCount;
            const sampleRate = audioContext.sampleRate;
            const nyquist = sampleRate / 2;

            // Calculate bin indices for frequency bands
            const bassEnd = Math.floor((250 / nyquist) * bufferLength);
            const midsEnd = Math.floor((2000 / nyquist) * bufferLength);

            // Calculate ALL frequency bands independently
            let bassSum = 0, midsSum = 0, highsSum = 0;
            let bassCount = 0, midsCount = 0, highsCount = 0;

            // Bass: 20-250 Hz
            for (let i = 0; i < bassEnd; i++) {
                bassSum += audioDataArray[i];
                bassCount++;
            }

            // Mids: 250-2000 Hz
            for (let i = bassEnd; i < midsEnd; i++) {
                midsSum += audioDataArray[i];
                midsCount++;
            }

            // Highs: 2000+ Hz
            for (let i = midsEnd; i < bufferLength; i++) {
                highsSum += audioDataArray[i];
                highsCount++;
            }

            // Calculate averages
            const bassAvg = bassCount > 0 ? bassSum / bassCount : 0;
            const midsAvg = midsCount > 0 ? midsSum / midsCount : 0;
            const highsAvg = highsCount > 0 ? highsSum / highsCount : 0;

            // Normalize each band to 0-1 range and amplify
            bassAmplitude = Math.min((bassAvg / 128) * 3, 5);
            midsAmplitude = Math.min((midsAvg / 128) * 3, 5);
            highsAmplitude = Math.min((highsAvg / 128) * 3, 5);

            // Set currentAudioAmplitude based on selected mode (for backward compatibility)
            if (audioFrequencyMode === 'bass') {
                currentAudioAmplitude = bassAmplitude;
            } else if (audioFrequencyMode === 'mids') {
                currentAudioAmplitude = midsAmplitude;
            } else if (audioFrequencyMode === 'highs') {
                currentAudioAmplitude = highsAmplitude;
            } else {
                // All frequencies - use weighted average (bass weighted more)
                currentAudioAmplitude = (bassAmplitude * 0.5 + midsAmplitude * 0.3 + highsAmplitude * 0.2);
            }
        }

        // Play/Pause
        function playPause() {
            // Multi-stem mode
            if (isMultiStemMode && stemWavesurfers.length > 0) {
                const isPlaying = stemWavesurfers[0].isPlaying();
                stemWavesurfers.forEach(ws => {
                    if (isPlaying) ws.pause();
                    else ws.play();
                });
                const icon = document.getElementById('playPauseIcon');
                icon.textContent = isPlaying ? '▶' : '||';
                const miniIcon = document.getElementById('miniPlayPauseIcon');
                if (miniIcon) miniIcon.textContent = isPlaying ? '▶' : '||';
                updatePlayButtonIcon();
                return;
            }

            // If no file is loaded, play a random visible file
            if (!wavesurfer || !currentFileId) {
                const eligibleFiles = getEligibleFiles();
                if (eligibleFiles.length > 0) {
                    const randomIndex = Math.floor(Math.random() * eligibleFiles.length);
                    loadAndPlayFile(eligibleFiles[randomIndex]);
                }
                return;
            }

            // Otherwise, toggle play/pause
            wavesurfer.playPause();
            const icon = document.getElementById('playPauseIcon');
            icon.textContent = wavesurfer.isPlaying() ? '||' : '▶';
            const miniIcon = document.getElementById('miniPlayPauseIcon');
            if (miniIcon) miniIcon.textContent = wavesurfer.isPlaying() ? '||' : '▶';
            updatePlayButtonIcon();
        }

        // Stop player
        function stopPlayer() {
            if (wavesurfer) {
                wavesurfer.stop();
                wavesurfer.destroy();
                wavesurfer = null;
            }
            stopMultiStem();
            isMultiStemMode = false;
            document.getElementById('bottomPlayer').classList.remove('active');
            currentFileId = null;
        }

        // Update player time display
        // Format time in seconds to MM:SS
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function updatePlayerTime() {
            if (!wavesurfer) return;

            const current = wavesurfer.getCurrentTime();
            const duration = wavesurfer.getDuration();

            document.getElementById('playerTime').textContent =
                `${formatTime(current)} / ${formatTime(duration)}`;
        }

        // Set volume
        function setVolume(value) {
            const volume = value / 100;

            // In multi-stem mode, control all stems
            if (isMultiStemMode && stemWavesurfers.length > 0) {
                stemWavesurfers.forEach(ws => {
                    if (ws) ws.setVolume(volume);
                });
            } else if (wavesurfer) {
                wavesurfer.setVolume(volume);
            }

            document.getElementById('volumePercent').textContent = `${value}%`;
        }

        // Adjust volume by delta (for keyboard shortcuts)
        function adjustVolume(delta) {
            const slider = document.getElementById('volumeSlider');
            let newVolume = parseInt(slider.value) + delta;
            newVolume = Math.max(0, Math.min(100, newVolume)); // Clamp 0-100
            slider.value = newVolume;
            setVolume(newVolume);
        }

        // Get files that are eligible for playback (respects all filters)
        function getEligibleFiles() {
            return audioFiles.filter(file => {
                // Check category visibility
                const fileCategory = getCategoryForFile(file);
                if (hiddenCategories.has(fileCategory)) {
                    return false;
                }

                // Check search filter
                if (searchFilteredFileIds.size > 0 && !searchFilteredFileIds.has(file.id)) {
                    return false;
                }

                // Check tag filter
                if (tagFilteredFileIds.size > 0 && !tagFilteredFileIds.has(file.id)) {
                    return false;
                }

                return true;
            });
        }

        // Play next track in sequence (or random if shuffle enabled)
        function playNextTrack() {
            if (audioFiles.length === 0) return;

            // Flash the next button
            flashButton('nextBtn');

            if (isShuffling) {
                playRandomFile();
                return;
            }

            // Get eligible files (respecting all filters)
            let navFiles = getEligibleFiles();

            // Further filter by category if in color nav mode
            if (navMode === 'color' && currentNavCategory) {
                navFiles = navFiles.filter(f => getCategoryForFile(f) === currentNavCategory);
                console.log(`COLOR mode: ${navFiles.length} files in category "${currentNavCategory}"`);
            }

            if (navFiles.length === 0) {
                console.log('No eligible files to play');
                return;
            }

            // If no current file, play first file in nav list
            if (!currentFileId) {
                console.log('No current file, playing first in nav list');
                loadAndPlayFile(navFiles[0]);
                return;
            }

            // Find current file index in the nav list
            const currentIndex = navFiles.findIndex(f => f.id === currentFileId);
            if (currentIndex === -1) {
                // Current file not found in nav list, play first file
                console.log('Current file not in nav list, playing first');
                loadAndPlayFile(navFiles[0]);
                return;
            }

            // Play next file (wrap around to start)
            const nextIndex = (currentIndex + 1) % navFiles.length;
            console.log(`Next: currentIndex=${currentIndex}, nextIndex=${nextIndex}, total=${navFiles.length}`);
            loadAndPlayFile(navFiles[nextIndex]);
        }

        // Play previous track or restart current if near beginning
        function playPreviousOrRestart() {
            if (audioFiles.length === 0) return;

            // Flash the previous button
            flashButton('prevBtn');

            // Handle multi-stem mode differently
            if (isMultiStemMode && stemWavesurfers.length > 0) {
                const currentTime = wavesurfer ? wavesurfer.getCurrentTime() : 0;

                // If more than 3 seconds in, restart all stems
                if (currentTime > 3) {
                    const wasPlaying = wavesurfer && wavesurfer.isPlaying();

                    // Restart parent wavesurfer
                    if (wavesurfer) {
                        wavesurfer.stop();
                        wavesurfer.seekTo(0);
                        if (wasPlaying) wavesurfer.play();
                    }

                    // Restart all stem wavesurfers
                    stemWavesurfers.forEach(ws => {
                        if (ws) {
                            const stemWasPlaying = ws.isPlaying();
                            ws.stop();
                            ws.seekTo(0);
                            if (stemWasPlaying) ws.play();
                        }
                    });
                    return;
                }
                // Otherwise, fall through to play previous track
            }

            // Regular mode or at beginning of stem - check if we should restart
            if (currentFileId && wavesurfer && wavesurfer.getCurrentTime() > 3) {
                const wasPlaying = wavesurfer.isPlaying();
                wavesurfer.stop();  // Stop completely first
                wavesurfer.seekTo(0);  // Then seek to start
                if (wasPlaying) {
                    wavesurfer.play();  // Resume playing if it was playing
                }
                return;
            }

            // Get eligible files (respecting all filters)
            let navFiles = getEligibleFiles();

            // Further filter by category if in color nav mode
            if (navMode === 'color' && currentNavCategory) {
                navFiles = navFiles.filter(f => getCategoryForFile(f) === currentNavCategory);
            }

            if (navFiles.length === 0) {
                console.log('No eligible files to play');
                return;
            }

            // If no current file, play last file in nav list
            if (!currentFileId) {
                loadAndPlayFile(navFiles[navFiles.length - 1]);
                return;
            }

            // Otherwise play previous track
            const currentIndex = navFiles.findIndex(f => f.id === currentFileId);
            if (currentIndex === -1) {
                // Current file not found in nav list, play last file
                loadAndPlayFile(navFiles[navFiles.length - 1]);
                return;
            }

            // Play previous file (wrap around to end)
            const prevIndex = currentIndex === 0 ? navFiles.length - 1 : currentIndex - 1;
            loadAndPlayFile(navFiles[prevIndex]);
        }

        // Toggle navigation mode between ALL and COLOR
        function toggleNavMode() {
            if (navMode === 'all') {
                navMode = 'color';
                // Set current category from currently playing file
                if (currentFileId) {
                    const currentFile = audioFiles.find(f => f.id === currentFileId);
                    if (currentFile) {
                        currentNavCategory = getCategoryForFile(currentFile);
                    }
                }
                document.getElementById('navModeText').textContent = 'COLOR';
                document.getElementById('navModeBtn').style.background = 'rgba(102, 126, 234, 0.5)';
                console.log(`Navigation mode: COLOR (${currentNavCategory})`);
            } else {
                navMode = 'all';
                currentNavCategory = null;
                document.getElementById('navModeText').textContent = 'ALL';
                document.getElementById('navModeBtn').style.background = '';
                console.log('Navigation mode: ALL');
            }
        }

        // Flash a button briefly when activated
        function flashButton(buttonId) {
            const button = document.getElementById(buttonId);
            if (!button) return;

            button.style.background = 'rgba(102, 126, 234, 0.7)';
            button.style.transform = 'scale(1.1)';

            setTimeout(() => {
                button.style.background = '';
                button.style.transform = '';
            }, 200);
        }

        // Panel toggle functions
        function toggleMainPanel() {
            const panel = document.querySelector('.mode-controls');
            if (panel.style.display === 'none') {
                panel.style.display = 'block';
            } else {
                panel.style.display = 'none';
            }
        }

        function toggleTopBar() {
            const topBar = document.querySelector('.top-bar');
            const statsOverlay = document.querySelector('.stats-overlay');

            if (topBar.style.display === 'none') {
                topBar.style.display = 'flex';
                statsOverlay.style.display = 'block';
            } else {
                topBar.style.display = 'none';
                statsOverlay.style.display = 'none';
            }
        }

        // Hide/show all UI elements at once
        function toggleHideAll() {
            const topBar = document.querySelector('.top-bar');
            const statsOverlay = document.querySelector('.stats-overlay');
            const legend = document.querySelector('.tag-legend');
            const tagFilterPanel = document.getElementById('tagFilterPanel');
            const player = document.querySelector('.bottom-player');
            const controls = document.getElementById('controlsHint');
            const modeControls = document.querySelector('.mode-controls');
            const multiStemPlayer = document.getElementById('multiStemPlayer');

            // Check if currently hidden (check top bar as indicator)
            const isHidden = topBar.style.display === 'none';

            if (isHidden) {
                // Show all - unlock pointer for editing
                topBar.style.display = 'flex';
                statsOverlay.style.display = 'block';
                legend.style.display = 'flex';
                tagFilterPanel.classList.remove('hidden');
                player.classList.add('active');
                modeControls.style.display = 'block';
                if (isMultiStemMode && multiStemPlayer) {
                    multiStemPlayer.style.display = 'block';
                }

                // Update color legend position after showing panels
                setTimeout(updateColorLegendPosition, 10);

                // Unlock pointer so user can interact with controls
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            } else {
                // Hide all - lock pointer for navigation
                topBar.style.display = 'none';
                statsOverlay.style.display = 'none';
                legend.style.display = 'none';
                tagFilterPanel.classList.add('hidden');
                player.classList.remove('active');
                controls.style.display = 'none';
                modeControls.style.display = 'none';
                if (multiStemPlayer) {
                    multiStemPlayer.style.display = 'none';
                }

                // Update color legend position after hiding panels
                setTimeout(updateColorLegendPosition, 10);

                // Lock pointer for FPS-style navigation (desktop only)
                if (!isMobileDevice) {
                    const canvas = renderer.domElement;
                    if (canvas && !document.pointerLockElement) {
                        canvas.requestPointerLock();
                    }
                }
            }
        }

        function toggleBottomPlayer() {
            const player = document.querySelector('.bottom-player');
            player.classList.toggle('active');
        }

        // Toggle tooltips
        function toggleTooltips() {
            tooltipsEnabled = !tooltipsEnabled;
            const btn = document.getElementById('tooltipToggleBtn');
            if (btn) btn.textContent = `Tooltips: ${tooltipsEnabled ? 'ON' : 'OFF'}`;

            const galaxyBtn = document.getElementById('galaxyTooltipToggle');
            if (galaxyBtn) galaxyBtn.textContent = `Tooltips: ${tooltipsEnabled ? 'ON' : 'OFF'}`;

            // Hide tooltip if disabling
            if (!tooltipsEnabled) {
                hideFileTooltip();
            }
        }

        // Toggle crosshair
        function toggleCrosshair() {
            crosshairEnabled = !crosshairEnabled;
            const crosshair = document.querySelector('.crosshair');
            const btn = document.getElementById('crosshairToggleBtn');
            const galaxyBtn = document.getElementById('galaxyCrosshairToggle');

            crosshair.style.display = crosshairEnabled ? 'block' : 'none';
            if (btn) btn.textContent = `Crosshair: ${crosshairEnabled ? 'ON' : 'OFF'}`;
            if (galaxyBtn) galaxyBtn.textContent = `Crosshair: ${crosshairEnabled ? 'ON' : 'OFF'}`;
        }

        // Toggle info window
        let infoWindowEnabled = false;
        function toggleInfoWindow() {
            infoWindowEnabled = !infoWindowEnabled;
            const infoWindow = document.getElementById('infoWindow');
            const galaxyBtn = document.getElementById('galaxyInfoToggle');

            if (infoWindowEnabled) {
                infoWindow.classList.add('visible');
                updateInfoWindow();
            } else {
                infoWindow.classList.remove('visible');
            }

            if (galaxyBtn) galaxyBtn.textContent = `Info Window: ${infoWindowEnabled ? 'ON' : 'OFF'}`;
        }

        // Toggle move joystick
        let moveJoystickEnabled = true;
        function toggleMoveJoystick() {
            moveJoystickEnabled = !moveJoystickEnabled;
            const moveJoystick = document.getElementById('joystickZone');
            const galaxyBtn = document.getElementById('galaxyMoveJoystickToggle');

            if (moveJoystick) {
                moveJoystick.style.display = moveJoystickEnabled ? 'block' : 'none';
            }
            if (galaxyBtn) galaxyBtn.textContent = `Move Joystick: ${moveJoystickEnabled ? 'ON' : 'OFF'}`;
        }

        // Toggle look joystick
        let lookJoystickEnabled = true;
        function toggleLookJoystick() {
            lookJoystickEnabled = !lookJoystickEnabled;
            const lookJoystick = document.getElementById('lookJoystickZone');
            const galaxyBtn = document.getElementById('galaxyLookJoystickToggle');

            if (lookJoystick) {
                lookJoystick.style.display = lookJoystickEnabled ? 'flex' : 'none';
            }
            if (galaxyBtn) galaxyBtn.textContent = `Look Joystick: ${lookJoystickEnabled ? 'ON' : 'OFF'}`;
        }

        // Toggle play button
        let playButtonEnabled = true;
        function togglePlayButton() {
            playButtonEnabled = !playButtonEnabled;
            const playBtn = document.getElementById('playBtn');
            const galaxyBtn = document.getElementById('galaxyPlayButtonToggle');

            if (playBtn) {
                playBtn.style.display = playButtonEnabled ? 'flex' : 'none';
            }
            if (galaxyBtn) galaxyBtn.textContent = `Play Button: ${playButtonEnabled ? 'ON' : 'OFF'}`;
        }

        // Update info window with current data
        function updateInfoWindow() {
            if (!infoWindowEnabled) return;

            // Update file count
            document.getElementById('infoFileCount').textContent = particles.length;

            // Update camera position in one row
            const x = camera.position.x.toFixed(0);
            const y = camera.position.y.toFixed(0);
            const z = camera.position.z.toFixed(0);
            document.getElementById('infoCameraPos').textContent = `${x}, ${y}, ${z}`;

            // Update targeted file info
            const targetedFileName = document.getElementById('targetedFile').textContent;
            const targetSection = document.getElementById('infoTargetSection');

            if (targetedFileName && targetedFileName !== 'None') {
                targetSection.style.display = 'block';
                document.getElementById('infoTargetFile').textContent =
                    targetedFileName.length > 25 ? targetedFileName.substring(0, 25) + '...' : targetedFileName;

                // Find the targeted file to get its metadata
                const targetedFile = audioFiles.find(f => f.name === targetedFileName);
                if (targetedFile) {
                    // BPM
                    const bpmRow = document.getElementById('infoTargetBPMRow');
                    if (targetedFile.bpm) {
                        bpmRow.style.display = 'flex';
                        document.getElementById('infoTargetBPM').textContent = targetedFile.bpm;
                    } else {
                        bpmRow.style.display = 'none';
                    }

                    // Key
                    const keyRow = document.getElementById('infoTargetKeyRow');
                    if (targetedFile.key) {
                        keyRow.style.display = 'flex';
                        document.getElementById('infoTargetKey').textContent = targetedFile.key;
                    } else {
                        keyRow.style.display = 'none';
                    }

                    // Tags
                    const tagsRow = document.getElementById('infoTargetTagsRow');
                    if (targetedFile.tags && targetedFile.tags.length > 0) {
                        tagsRow.style.display = 'flex';
                        const tagsText = targetedFile.tags.slice(0, 3).join(', ');
                        document.getElementById('infoTargetTags').textContent =
                            tagsText.length > 30 ? tagsText.substring(0, 30) + '...' : tagsText;
                    } else {
                        tagsRow.style.display = 'none';
                    }
                }
            } else {
                targetSection.style.display = 'none';
            }
        }

        // Toggle key commands legend
        function toggleKeyCommandsLegend() {
            const legend = document.getElementById('keyCommandsLegend');
            legend.style.display = legend.style.display === 'none' ? 'block' : 'none';
        }

        // Toggle color legend
        function toggleColorLegend() {
            const legend = document.getElementById('tagLegend');
            const searchInput = document.getElementById('fileSearchInput');

            if (legend.style.display === 'none') {
                legend.style.display = 'flex';
            } else {
                // Clear search when closing
                if (searchInput) {
                    searchInput.value = '';
                    handleSearch(''); // Reset search filter
                }
                legend.style.display = 'none';
            }
        }

        // Tag Filter Panel (Library-style filtering)
        let tagFilters = {
            canHave: new Set(),
            mustHave: new Set(),
            exclude: new Set()
        };
        let currentFilterMode = null;
        let tagFilterSearchTerm = '';

        function toggleTagFilterPanel() {
            const panel = document.getElementById('tagFilterPanel');
            panel.classList.toggle('hidden');

            if (!panel.classList.contains('hidden')) {
                renderTagFilterButtons();
            }

            // Update color legend position after a short delay to allow panel to render
            setTimeout(updateColorLegendPosition, 10);
        }

        function toggleTagFilterCollapse() {
            const panel = document.getElementById('tagFilterPanel');
            const button = panel.querySelector('.collapse-btn');
            panel.classList.toggle('collapsed');
            button.textContent = panel.classList.contains('collapsed') ? '▼' : '▲';
            updateColorLegendPosition();
        }

        function updateColorLegendPosition() {
            const tagFilterPanel = document.getElementById('tagFilterPanel');
            const colorLegend = document.getElementById('tagLegend');

            if (!tagFilterPanel || !colorLegend) return;

            // If tag filter is visible (not hidden by Y key), position color legend below it
            if (!tagFilterPanel.classList.contains('hidden')) {
                const tagFilterHeight = tagFilterPanel.offsetHeight;
                colorLegend.style.top = (200 + tagFilterHeight + 10) + 'px'; // 10px gap
            } else {
                // Tag filter is hidden (Y key pressed), position color legend at default position
                colorLegend.style.top = '200px';
            }
        }

        function toggleColorLegendCollapse() {
            const legend = document.getElementById('tagLegend');
            const button = legend.querySelector('.collapse-btn');
            legend.classList.toggle('collapsed');
            button.textContent = legend.classList.contains('collapsed') ? '▼' : '▲';
        }

        function setFilterMode(mode) {
            // Toggle mode selection
            if (currentFilterMode === mode) {
                currentFilterMode = null;
            } else {
                currentFilterMode = mode;
            }

            // Update button states
            document.getElementById('canHaveBtn').classList.toggle('active', currentFilterMode === 'canHave');
            document.getElementById('mustHaveBtn').classList.toggle('active', currentFilterMode === 'mustHave');
            document.getElementById('excludeBtn').classList.toggle('active', currentFilterMode === 'exclude');
        }

        function handleTagFilterSearch(value) {
            tagFilterSearchTerm = value.toLowerCase().trim();
            renderTagFilterButtons();
        }

        function getAllUniqueTags() {
            const tagCounts = {};
            audioFiles.forEach(file => {
                (file.tags || []).forEach(tag => {
                    tagCounts[tag] = (tagCounts[tag] || 0) + 1;
                });
            });

            return Object.entries(tagCounts)
                .sort((a, b) => b[1] - a[1]) // Sort by count descending
                .map(([tag, count]) => ({ tag, count }));
        }

        function renderTagFilterButtons() {
            const container = document.getElementById('tagButtonsContainer');
            const allTags = getAllUniqueTags();

            // Filter by search term
            let filteredTags = allTags;
            if (tagFilterSearchTerm) {
                filteredTags = allTags.filter(({ tag }) =>
                    tag.toLowerCase().includes(tagFilterSearchTerm)
                );
            }

            if (filteredTags.length === 0) {
                container.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No tags found</div>';
                return;
            }

            // Render tag buttons
            container.innerHTML = filteredTags.map(({ tag, count }) => {
                let className = 'tag-filter-button';
                if (tagFilters.canHave.has(tag)) className += ' can-have';
                if (tagFilters.mustHave.has(tag)) className += ' must-have';
                if (tagFilters.exclude.has(tag)) className += ' exclude';

                return `<button class="${className}" onclick="handleTagFilterClick('${tag}', event)">${tag} (${count})</button>`;
            }).join('');

            updateActiveFiltersDisplay();

            // Update color legend position after rendering (with delay to allow DOM to update)
            setTimeout(updateColorLegendPosition, 10);
        }

        function handleTagFilterClick(tag, event) {
            event.preventDefault();

            // Determine mode: use currentFilterMode or modifier keys
            let mode = currentFilterMode;
            if (event.altKey) {
                mode = 'exclude';
            } else if (event.shiftKey) {
                mode = 'mustHave';
            } else if (!mode) {
                mode = 'canHave'; // Default
            }

            // Check if already in this mode - if so, remove it
            const isAlreadyInMode =
                (mode === 'canHave' && tagFilters.canHave.has(tag)) ||
                (mode === 'mustHave' && tagFilters.mustHave.has(tag)) ||
                (mode === 'exclude' && tagFilters.exclude.has(tag));

            // Remove from all filters first
            tagFilters.canHave.delete(tag);
            tagFilters.mustHave.delete(tag);
            tagFilters.exclude.delete(tag);

            // If not already in mode, add it
            if (!isAlreadyInMode) {
                if (mode === 'canHave') tagFilters.canHave.add(tag);
                else if (mode === 'mustHave') tagFilters.mustHave.add(tag);
                else if (mode === 'exclude') tagFilters.exclude.add(tag);
            }

            renderTagFilterButtons();
            applyTagFilters();
        }

        function updateActiveFiltersDisplay() {
            const display = document.getElementById('activeFiltersDisplay');
            const parts = [];

            if (tagFilters.canHave.size > 0) {
                parts.push(`CAN: ${Array.from(tagFilters.canHave).join(', ')}`);
            }
            if (tagFilters.mustHave.size > 0) {
                parts.push(`MUST: ${Array.from(tagFilters.mustHave).join(', ')}`);
            }
            if (tagFilters.exclude.size > 0) {
                parts.push(`EXCLUDE: ${Array.from(tagFilters.exclude).join(', ')}`);
            }

            display.textContent = parts.length > 0 ? parts.join(' | ') : 'No active filters';
        }

        function applyTagFilters() {
            // Update global tagFilteredFileIds based on tag filter logic
            tagFilteredFileIds.clear();

            if (tagFilters.canHave.size === 0 && tagFilters.mustHave.size === 0 && tagFilters.exclude.size === 0) {
                // No filters active - clear the set (empty set means show all in animate loop)
                console.log('Tag filters cleared - showing all files');
                return;
            }

            // Apply filter logic to determine which files match
            audioFiles.forEach(file => {
                const fileTags = new Set(file.tags || []);

                // Check EXCLUDE - if file has any excluded tag, skip it
                let excluded = false;
                for (let tag of tagFilters.exclude) {
                    if (fileTags.has(tag)) {
                        excluded = true;
                        break;
                    }
                }
                if (excluded) return;

                // Check MUST HAVE - file must have ALL must-have tags
                for (let tag of tagFilters.mustHave) {
                    if (!fileTags.has(tag)) return;
                }

                // Check CAN HAVE - if can-have filters exist, file must have at least one
                if (tagFilters.canHave.size > 0) {
                    let hasCanHave = false;
                    for (let tag of tagFilters.canHave) {
                        if (fileTags.has(tag)) {
                            hasCanHave = true;
                            break;
                        }
                    }
                    if (!hasCanHave) return;
                }

                // File passed all filter checks
                tagFilteredFileIds.add(file.id);
            });

            console.log(`Tag filters applied - ${tagFilteredFileIds.size} files match out of ${audioFiles.length}`);
        }

        function clearAllTagFilters() {
            tagFilters.canHave.clear();
            tagFilters.mustHave.clear();
            tagFilters.exclude.clear();
            currentFilterMode = null;

            // Update button states
            document.getElementById('canHaveBtn').classList.remove('active');
            document.getElementById('mustHaveBtn').classList.remove('active');
            document.getElementById('excludeBtn').classList.remove('active');

            renderTagFilterButtons();
            applyTagFilters();
        }

        // Keyboard handlers
        function onKeyDown(event) {
            // Track shift key separately - if shift state changes, clear movement keys to prevent sticking
            const previousShiftState = isShiftPressed;
            isShiftPressed = event.shiftKey;

            // If shift state changed, clear all movement keys to prevent lock
            if (previousShiftState !== isShiftPressed) {
                keys = {};
            }

            // Spacebar for play/pause (don't add to movement keys)
            if (event.key === ' ' || event.code === 'Space') {
                event.preventDefault();
                playPause();
                return;
            }

            // Toggle panels with keyboard shortcuts (only when not in a text input AND no modifiers pressed)
            // Don't trigger shortcuts when Command, Control, or Alt are pressed (allow browser shortcuts)
            const hasModifier = event.metaKey || event.ctrlKey || event.altKey;

            if (!event.target.matches('input, textarea') && !hasModifier) {
                // / key (without shift) - Toggle BOTH controls hint AND keyboard commands
                if (event.key === '/') {
                    event.preventDefault();
                    toggleControlsHint();
                    toggleKeyboardCommands();
                    return;
                }
                // T key - Toggle multi-stem Tracks window
                if (event.key === 't' || event.key === 'T') {
                    event.preventDefault();
                    toggleMultiStemPlayer();
                    return;
                }
                // O key - Toggle right options menu
                if (event.key === 'o' || event.key === 'O') {
                    event.preventDefault();
                    toggleModeControls();
                    return;
                }
                // I key - Toggle top-left info window
                if (event.key === 'i' || event.key === 'I') {
                    event.preventDefault();
                    toggleStatsOverlay();
                    return;
                }
                if (event.key === 'm' || event.key === 'M') {
                    event.preventDefault();
                    toggleTopBar();
                    return;
                }
                if (event.key === 'p' || event.key === 'P') {
                    event.preventDefault();
                    toggleBottomPlayer();
                    return;
                }

                // Loop toggle (L key)
                if (event.key === 'l' || event.key === 'L') {
                    event.preventDefault();
                    toggleLoop();
                    return;
                }

                // Shuffle/Random toggle (R key)
                if (event.key === 'r' || event.key === 'R') {
                    event.preventDefault();
                    toggleShuffle();
                    return;
                }

                // Toggle key commands (? key - can use / with shift)
                if (event.key === '?' || event.key === '/') {
                    event.preventDefault();
                    toggleKeyCommandsLegend();
                    return;
                }

                // Volume down (- key)
                if (event.key === '-' || event.key === '_') {
                    event.preventDefault();
                    adjustVolume(-10);
                    return;
                }

                // Volume up (= key, which is + without shift)
                if (event.key === '=' || event.key === '+') {
                    event.preventDefault();
                    adjustVolume(10);
                    return;
                }

                // Next track (. key)
                if (event.key === '.' || event.key === '>') {
                    event.preventDefault();
                    playNextTrack();
                    return;
                }

                // Previous/restart track (, key)
                if (event.key === ',' || event.key === '<') {
                    event.preventDefault();
                    playPreviousOrRestart();
                    return;
                }

                // Toggle color legend (C key) and focus search
                if (event.key === 'c' || event.key === 'C') {
                    event.preventDefault();
                    const legend = document.getElementById('tagLegend');
                    const searchInput = document.getElementById('fileSearchInput');

                    // If legend is hidden, show it and focus search
                    if (legend.style.display === 'none') {
                        toggleColorLegend();
                        setTimeout(() => {
                            if (searchInput) {
                                searchInput.focus();
                                searchInput.select();
                            }
                        }, 50);
                    } else {
                        // If already visible, just toggle it closed
                        toggleColorLegend();
                    }
                    return;
                }

                // Toggle tag filter panel (Y key) and focus search
                if (event.key === 'y' || event.key === 'Y') {
                    event.preventDefault();
                    const panel = document.getElementById('tagFilterPanel');
                    const tagSearchInput = document.getElementById('tagFilterSearch');

                    // If panel is hidden, show it and focus search
                    if (panel.classList.contains('hidden')) {
                        toggleTagFilterPanel();
                        setTimeout(() => {
                            if (tagSearchInput) {
                                tagSearchInput.focus();
                                tagSearchInput.select();
                            }
                        }, 50);
                    } else {
                        // If already visible, just toggle it closed
                        toggleTagFilterPanel();
                    }
                    return;
                }

                // Hide/show all UI elements (H key)
                if (event.key === 'h' || event.key === 'H') {
                    event.preventDefault();
                    toggleHideAll();
                    return;
                }
            }

            // Prevent default for arrow keys to avoid page scrolling (but not in text inputs)
            if (event.key.startsWith('Arrow') && !event.target.matches('input, textarea')) {
                event.preventDefault();
            }

            // Don't track shift keys in the keys object
            if (event.key === 'Shift') {
                return;
            }

            // Don't track movement keys when typing in text fields
            if (event.target.matches('input, textarea')) {
                return;
            }

            keys[event.key] = true;

            // ESC to exit pointer lock only (don't stop playback)
            if (event.key === 'Escape') {
                if (document.pointerLockElement) {
                    document.exitPointerLock();
                }
            }
        }

        function onKeyUp(event) {
            // Track shift key separately - if shift state changes, clear movement keys to prevent sticking
            const previousShiftState = isShiftPressed;
            isShiftPressed = event.shiftKey;

            // If shift state changed, clear all movement keys to prevent lock
            if (previousShiftState !== isShiftPressed) {
                keys = {};
            }

            // Don't track spacebar in keys object
            if (event.key === ' ' || event.code === 'Space') {
                event.preventDefault();
                return;
            }

            // Prevent default for arrow keys (but not in text inputs)
            if (event.key.startsWith('Arrow') && !event.target.matches('input, textarea')) {
                event.preventDefault();
            }

            // Don't track shift keys in the keys object
            if (event.key === 'Shift') {
                return;
            }

            // Don't track movement keys when typing in text fields
            if (event.target.matches('input, textarea')) {
                return;
            }

            keys[event.key] = false;
        }

        // Mouse wheel to adjust movement speed
        // Mouse wheel function removed - was preventing menu scrolling

        // Reset camera
        function resetCamera() {
            camera.position.set(0, 10, 30);
            yaw = 0;
            pitch = 0;
            camera.rotation.set(0, 0, 0);
        }

        // Toggle controls hint (left panel) - called by ? or \ key
        function toggleControlsHint() {
            const hint = document.getElementById('controlsHint');
            const isHidden = hint.style.display === 'none';
            hint.style.display = isHidden ? 'block' : 'none';
        }

        // Toggle mode controls (right panel)
        function toggleModeControls() {
            const modeControls = document.querySelector('.mode-controls');
            const isHidden = modeControls.style.display === 'none';
            modeControls.style.display = isHidden ? 'block' : 'none';
        }

        // Toggle stats overlay (top-left info)
        function toggleStatsOverlay() {
            const statsOverlay = document.querySelector('.stats-overlay');
            const isHidden = statsOverlay.style.display === 'none';
            statsOverlay.style.display = isHidden ? 'block' : 'none';
        }

        // Window resize handler
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        // Toggle loop
        function toggleLoop() {
            isLooping = !isLooping;
            const loopBtn = document.getElementById('loopBtn');
            const shuffleBtn = document.getElementById('shuffleBtn');

            loopBtn.classList.toggle('active', isLooping);

            // Gray out shuffle button when loop is active (loop overrides shuffle)
            if (isLooping) {
                shuffleBtn.style.opacity = '0.4';
                shuffleBtn.style.cursor = 'not-allowed';
            } else {
                shuffleBtn.style.opacity = '1';
                shuffleBtn.style.cursor = 'pointer';
            }
        }

        // Toggle shuffle
        function toggleShuffle() {
            // Prevent toggling shuffle when loop is active
            if (isLooping) return;

            isShuffling = !isShuffling;
            const btn = document.getElementById('shuffleBtn');
            btn.classList.toggle('active', isShuffling);
        }

        // Toggle stem player expand/collapse (default collapsed)
        let stemPlayerExpanded = false;
        function toggleStemExpand() {
            stemPlayerExpanded = !stemPlayerExpanded;
            const multiStemPlayer = document.getElementById('multiStemPlayer');
            const expandIcon = document.getElementById('stemExpandIcon');
            const stemExpandBtn = document.getElementById('stemExpandBtn');

            if (stemPlayerExpanded) {
                // Expanding
                multiStemPlayer.classList.remove('collapsed');
                expandIcon.textContent = '▼ STEMS';

                // Remove highlight when expanded
                if (stemExpandBtn) {
                    stemExpandBtn.style.background = 'transparent';
                    stemExpandBtn.style.border = '1px solid rgba(255, 255, 255, 0.15)';
                }

                // Update body class and height for Options menu
                document.body.classList.add('multi-stem-active');
                setTimeout(() => {
                    const height = multiStemPlayer.offsetHeight;
                    document.body.style.setProperty('--multi-stem-height', `${height}px`);
                }, 50);
            } else {
                // Collapsing
                multiStemPlayer.classList.add('collapsed');
                expandIcon.textContent = '▲ STEMS';

                // Highlight when collapsed (indicates stems are available)
                if (stemExpandBtn) {
                    stemExpandBtn.style.background = 'rgba(102,126,234,0.3)';
                    stemExpandBtn.style.border = '1px solid #667eea';
                }

                // Remove body class and reset height
                document.body.classList.remove('multi-stem-active');
                document.body.style.setProperty('--multi-stem-height', '0px');
            }
        }

        // Update stem galaxy offset distance
        function updateStemOffset(value) {
            stemGalaxyOffset = parseFloat(value);
            document.getElementById('stemOffsetValue').textContent = value;

            // Reload data to apply new offset
            updateDataSources();
        }

        // Play random file (for shuffle)
        function playRandomFile() {
            // Get eligible files (respecting all filters)
            const eligibleFiles = getEligibleFiles();

            if (eligibleFiles.length === 0) {
                console.log('No eligible files for shuffle');
                return;
            }

            const randomIndex = Math.floor(Math.random() * eligibleFiles.length);
            const randomFile = eligibleFiles[randomIndex];
            loadAndPlayFile(randomFile);
        }

        // Motion control functions
        function updateMotionSpeed(value) {
            orbitSpeed = parseFloat(value);
            document.getElementById('speedValue').textContent = (value * 100).toFixed(1);
            document.getElementById('speedInput').value = value;
        }

        function updateMotionSpeedDirect(value) {
            const numValue = parseFloat(value);
            orbitSpeed = numValue;
            document.getElementById('speedValue').textContent = (numValue * 100).toFixed(1);
            document.getElementById('speedSlider').value = numValue;
        }

        function updateMotionRadius(value) {
            orbitRadius = parseFloat(value);
            document.getElementById('radiusValue').textContent = value;
        }

        function updateRotationMode(value) {
            rotationMode = value;
        }

        function updateRotationAxis(value) {
            rotationAxis = value;
        }

        function updateParticleSize(value) {
            particleSize = parseFloat(value);
            document.getElementById('sizeValue').textContent = value;
            // Size is applied in the animation loop via instance matrix scaling
        }

        function updateParticleShape(value) {
            particleShape = value;
            if (particleSystem && particleSystem.material) {
                particleSystem.material.map = createParticleTexture(value);
                particleSystem.material.needsUpdate = true;
            }
        }

        function updateParticleBrightness(value) {
            particleBrightness = parseFloat(value);
            document.getElementById('brightnessValue').textContent = value;
            if (particleSystem && particleSystem.material) {
                particleSystem.material.opacity = particleBrightness;
            }
        }

        function updateVisibility(value) {
            visibilityDistance = parseFloat(value);
            document.getElementById('visibilityValue').textContent = value;
            // Update fog and camera far plane
            if (scene.fog) {
                scene.fog.far = visibilityDistance;
            }
            if (camera) {
                camera.far = visibilityDistance * 2;
                camera.updateProjectionMatrix();
            }
        }

        function updateXAxisScale(value) {
            xAxisScale = parseFloat(value);
            document.getElementById('xAxisScaleValue').textContent = value;
            updateClusterPositions();
        }

        function updateYAxisScale(value) {
            yAxisScale = parseFloat(value);
            document.getElementById('yAxisScaleValue').textContent = value;
            updateClusterPositions();
        }

        function updateZAxisScale(value) {
            zAxisScale = parseFloat(value);
            document.getElementById('zAxisScaleValue').textContent = value;
            updateClusterPositions();
        }

        function updateClusterPositions() {
            if (particles.length > 0) {
                particles.forEach((cluster, index) => {
                    const newPos = calculateFilePosition(cluster.file, index);
                    cluster.centerPosition.set(newPos.x, newPos.y, newPos.z);
                });
            }
        }

        function updateClusterSpread(value) {
            clusterRadius = parseFloat(value);
            document.getElementById('clusterSpreadValue').textContent = value;
            // Update existing cluster sub-particle offsets using stored base radius
            if (particles.length > 0 && particleSystem) {
                particles.forEach(cluster => {
                    cluster.subParticles.forEach(subParticle => {
                        // Skip center particles
                        if (subParticle.isCenterParticle) {
                            return;
                        }
                        // Recalculate offset with new radius using stored baseRadius
                        const normalized = subParticle.offset.clone().normalize();
                        subParticle.offset.copy(normalized.multiplyScalar(clusterRadius * subParticle.baseRadius));
                    });
                });
            }
        }

        function updateSubParticleSize(value) {
            subParticleScale = parseFloat(value);
            document.getElementById('subParticleSizeValue').textContent = value;
        }

        function updateMainToSubRatio(value) {
            mainToSubSizeRatio = parseFloat(value);
            document.getElementById('mainToSubRatioValue').textContent = value;
            // Size is applied in the animation loop via instance matrix scaling
        }

        function toggleMotion() {
            motionEnabled = !motionEnabled;
            const btn = document.getElementById('motionToggle');
            const galaxyBtn = document.getElementById('galaxyMotionToggle');

            if (btn) {
                btn.textContent = `Motion: ${motionEnabled ? 'ON' : 'OFF'}`;
                btn.style.background = motionEnabled ? 'rgba(102,126,234,0.3)' : 'rgba(255,255,255,0.1)';
            }
            if (galaxyBtn) galaxyBtn.textContent = `Motion: ${motionEnabled ? 'ON' : 'OFF'}`;
        }

        function updateHoverSpeed(value) {
            hoverSlowdown = parseFloat(value) / 100; // Convert percentage to decimal
            document.getElementById('hoverSpeedValue').textContent = value;
        }

        function updateHoverScale(value) {
            hoverScale = parseFloat(value);
            document.getElementById('hoverScaleValue').textContent = value;
        }

        function toggleMouseInteraction() {
            mouseInteractionEnabled = !mouseInteractionEnabled;
            const btn = document.getElementById('mouseInteractionToggle');
            btn.textContent = `Crosshair Hover: ${mouseInteractionEnabled ? 'ON' : 'OFF'}`;
            btn.style.background = mouseInteractionEnabled ? 'rgba(102,126,234,0.3)' : 'rgba(255,255,255,0.1)';
        }

        function updateAudioStrength(value) {
            audioReactivityStrength = parseFloat(value);
            document.getElementById('audioStrengthValue').textContent = value;
        }

        function updateGlobalReactivity(value) {
            globalAudioReactivity = parseFloat(value);
            document.getElementById('globalReactivityValue').textContent = value;
        }

        function updateSubParticleCount(value) {
            const newCount = parseInt(value);
            const oldCount = particlesPerCluster;
            console.log(`Updating sub-particle count from ${oldCount} to ${newCount}`);
            particlesPerCluster = newCount;
            document.getElementById('subParticleCountValue').textContent = value;

            // For now, we have to recreate particles when count changes
            // This is because InstancedMesh requires a fixed instance count
            // TODO: Consider using a larger fixed pool and hiding unused instances
            if (audioFiles.length > 0) {
                console.log(`Recreating ${audioFiles.length} clusters with ${particlesPerCluster} particles each`);
                createParticles();
            }
        }

        function updateSubParticleMotion(value) {
            subParticleMotionSpeed = parseFloat(value);
            document.getElementById('subParticleMotionValue').textContent = value;
        }

        function updateSubParticleSpeed(value) {
            subParticleAnimationSpeed = parseFloat(value);
            document.getElementById('subParticleSpeedValue').textContent = value;
        }

        function updateMotionPath(value) {
            subParticleMotionPath = value;
        }

        function updateSubParticleShape(value) {
            subParticleShape = value;
            // Recreate particles with new shape
            createParticles();
        }

        function updateSizeGradient(value) {
            sizeGradient = parseFloat(value);
            document.getElementById('sizeGradientValue').textContent = value;
            // Size is applied in animation loop, no need to recreate
        }

        function updateDensityGradient(value) {
            densityGradient = parseFloat(value);
            document.getElementById('densityGradientValue').textContent = value;
            createParticles(); // Recreate to spawn more particles
        }

        function updateBloomStrength(value) {
            bloomStrength = parseFloat(value);
            document.getElementById('bloomStrengthValue').textContent = value;
            // Bloom is applied in animation loop
        }

        function updateFrequencyMode(value) {
            audioFrequencyMode = value;
        }

        function toggleAudioReactivity() {
            audioReactivityEnabled = !audioReactivityEnabled;
            const btn = document.getElementById('audioReactivityToggle');
            btn.textContent = `Audio Reactivity: ${audioReactivityEnabled ? 'ON' : 'OFF'}`;
            btn.style.background = audioReactivityEnabled ? 'rgba(102,126,234,0.3)' : 'rgba(255,255,255,0.1)';
        }

        // Toggle collapsible sections
        function toggleSection(header) {
            header.classList.toggle('collapsed');
            const content = header.nextElementSibling;
            if (content && content.classList.contains('collapsible-content')) {
                content.classList.toggle('collapsed');
            }
        }

        // Options Menu 2 toggle function
        function toggleOptionsMenu2() {
            // Only toggle if we haven't just finished dragging
            if (optionsMenu2DragState.hasMoved) {
                optionsMenu2DragState.hasMoved = false;
                return;
            }

            const optionsMenu2 = document.getElementById('optionsMenu2');
            const collapseIcon = document.getElementById('optionsCollapseIcon2');
            const isCollapsed = optionsMenu2.classList.contains('options-collapsed');

            if (isCollapsed) {
                // Expand the menu
                optionsMenu2.classList.remove('options-collapsed');
                collapseIcon.textContent = '−';
            } else {
                // Collapse the menu
                optionsMenu2.classList.add('options-collapsed');
                collapseIcon.textContent = '+';
            }
        }

        // Options Menu 2 Drag Function (separate from Options Menu 1)
        function initOptionsMenu2Drag() {
            const optionsMenu2 = document.getElementById('optionsMenu2');
            const titleBar = optionsMenu2.querySelector('.options-title-bar');

            titleBar.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                optionsMenu2DragState.isDragging = true;
                optionsMenu2DragState.startX = touch.clientX;
                optionsMenu2DragState.startY = touch.clientY;
                optionsMenu2DragState.hasMoved = false;

                // Get current position
                const rect = optionsMenu2.getBoundingClientRect();
                optionsMenu2DragState.startMenuX = rect.left;
                optionsMenu2DragState.startMenuY = rect.top;

                optionsMenu2.classList.add('dragging');
                e.stopPropagation();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!optionsMenu2DragState.isDragging) return;

                const touch = e.touches[0];
                const deltaX = touch.clientX - optionsMenu2DragState.startX;
                const deltaY = touch.clientY - optionsMenu2DragState.startY;

                // If moved more than 5px, consider it a drag (not a click)
                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                    optionsMenu2DragState.hasMoved = true;
                }

                const newX = optionsMenu2DragState.startMenuX + deltaX;
                const newY = optionsMenu2DragState.startMenuY + deltaY;

                // Get menu dimensions
                const menuWidth = optionsMenu2.offsetWidth;
                const menuHeight = optionsMenu2.offsetHeight;

                // Keep within screen bounds
                const maxX = window.innerWidth - menuWidth;
                const maxY = window.innerHeight - menuHeight;

                let boundedX = Math.max(0, Math.min(newX, maxX));
                let boundedY = Math.max(0, Math.min(newY, maxY));

                // Collision detection with play button
                const playBtn = document.querySelector('.play-btn');
                if (playBtn && window.getComputedStyle(playBtn).display !== 'none') {
                    const playBtnRect = playBtn.getBoundingClientRect();

                    // Calculate menu bounds
                    const menuLeft = boundedX;
                    const menuRight = boundedX + menuWidth;
                    const menuTop = boundedY;
                    const menuBottom = boundedY + menuHeight;

                    // Check for overlap
                    const overlapsX = menuRight > playBtnRect.left && menuLeft < playBtnRect.right;
                    const overlapsY = menuBottom > playBtnRect.top && menuTop < playBtnRect.bottom;

                    if (overlapsX && overlapsY) {
                        // Determine which direction to push the menu
                        const overlapLeft = menuRight - playBtnRect.left;
                        const overlapRight = playBtnRect.right - menuLeft;
                        const overlapTop = menuBottom - playBtnRect.top;
                        const overlapBottom = playBtnRect.bottom - menuTop;

                        // Find minimum overlap to resolve collision
                        const minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);

                        if (minOverlap === overlapLeft) {
                            // Push left
                            boundedX = playBtnRect.left - menuWidth - 10;
                        } else if (minOverlap === overlapRight) {
                            // Push right
                            boundedX = playBtnRect.right + 10;
                        } else if (minOverlap === overlapTop) {
                            // Push up
                            boundedY = playBtnRect.top - menuHeight - 10;
                        } else {
                            // Push down
                            boundedY = playBtnRect.bottom + 10;
                        }

                        // Re-clamp to screen bounds after collision resolution
                        boundedX = Math.max(0, Math.min(boundedX, maxX));
                        boundedY = Math.max(0, Math.min(boundedY, maxY));
                    }
                }

                // Update position using left/top
                optionsMenu2.style.left = boundedX + 'px';
                optionsMenu2.style.top = boundedY + 'px';
                optionsMenu2.style.bottom = 'auto';

                // Store position
                optionsMenu2Position.x = boundedX;
                optionsMenu2Position.y = boundedY;
                optionsMenu2Position.bottom = null;

                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (!optionsMenu2DragState.isDragging) return;

                optionsMenu2DragState.isDragging = false;
                optionsMenu2.classList.remove('dragging');

                // Small delay before allowing toggle
                if (optionsMenu2DragState.hasMoved) {
                    setTimeout(() => {
                        optionsMenu2DragState.hasMoved = false;
                    }, 100);
                }
            });
        }

        // Options Menu 2 Resize Function
        const optionsMenu2ResizeState = {
            isResizing: false,
            startY: 0,
            startHeight: 0
        };

        function initOptionsMenu2Resize() {
            const optionsMenu2 = document.getElementById('optionsMenu2');
            const resizeHandle = document.getElementById('optionsResizeHandle');

            resizeHandle.addEventListener('touchstart', (e) => {
                // Only allow resize if menu is expanded
                if (optionsMenu2.classList.contains('options-collapsed')) return;

                const touch = e.touches[0];
                optionsMenu2ResizeState.isResizing = true;
                optionsMenu2ResizeState.startY = touch.clientY;
                optionsMenu2ResizeState.startHeight = optionsMenu2.offsetHeight;

                e.stopPropagation();
                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!optionsMenu2ResizeState.isResizing) return;

                const touch = e.touches[0];
                const deltaY = touch.clientY - optionsMenu2ResizeState.startY;
                const newHeight = optionsMenu2ResizeState.startHeight + deltaY;

                // Set min and max height constraints
                const minHeight = 200;  // Minimum height to keep menu usable
                const maxHeight = window.innerHeight - 40;  // Leave some margin from top

                const boundedHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));

                // Apply the new height
                optionsMenu2.style.height = boundedHeight + 'px';
                optionsMenu2.style.maxHeight = boundedHeight + 'px';

                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (!optionsMenu2ResizeState.isResizing) return;
                optionsMenu2ResizeState.isResizing = false;
            });
        }

        // Info Window Drag Function
        const infoWindowDragState = {
            isDragging: false,
            startX: 0,
            startY: 0,
            startWindowX: 0,
            startWindowY: 0,
            hasMoved: false
        };

        function initInfoWindowDrag() {
            const infoWindow = document.getElementById('infoWindow');
            const header = infoWindow.querySelector('.info-window-header');

            header.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                infoWindowDragState.isDragging = true;
                infoWindowDragState.startX = touch.clientX;
                infoWindowDragState.startY = touch.clientY;
                infoWindowDragState.hasMoved = false;

                const rect = infoWindow.getBoundingClientRect();
                infoWindowDragState.startWindowX = rect.left;
                infoWindowDragState.startWindowY = rect.top;

                e.stopPropagation();
            }, { passive: false });

            document.addEventListener('touchmove', (e) => {
                if (!infoWindowDragState.isDragging) return;

                const touch = e.touches[0];
                const deltaX = touch.clientX - infoWindowDragState.startX;
                const deltaY = touch.clientY - infoWindowDragState.startY;

                if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
                    infoWindowDragState.hasMoved = true;
                }

                const newX = infoWindowDragState.startWindowX + deltaX;
                const newY = infoWindowDragState.startWindowY + deltaY;

                // Keep within screen bounds
                const windowWidth = infoWindow.offsetWidth;
                const windowHeight = infoWindow.offsetHeight;
                const maxX = window.innerWidth - windowWidth;
                const maxY = window.innerHeight - windowHeight;

                const boundedX = Math.max(0, Math.min(newX, maxX));
                const boundedY = Math.max(0, Math.min(newY, maxY));

                infoWindow.style.left = boundedX + 'px';
                infoWindow.style.top = boundedY + 'px';

                e.preventDefault();
            }, { passive: false });

            document.addEventListener('touchend', (e) => {
                if (!infoWindowDragState.isDragging) return;
                infoWindowDragState.isDragging = false;
            });
        }

        // Toggle fullscreen mode
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                // Enter fullscreen
                document.documentElement.requestFullscreen().catch(err => {
                    console.log(`Error attempting to enable fullscreen: ${err.message}`);
                });
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        }

        // Preset system
        function getCurrentSettings() {
            // Read from Options 2 elements (galaxy* prefixed IDs) where they exist
            const colorModeEl = document.getElementById('galaxyColorMode');
            const xAxisModeEl = document.getElementById('galaxyXAxisMode');
            const yAxisModeEl = document.getElementById('galaxyYAxisMode');
            const zAxisModeEl = document.getElementById('galaxyZAxisMode');

            const settings = {
                // Visualization modes - read from Options 2
                colorMode: colorModeEl ? colorModeEl.value : currentColorMode,
                xMode: xAxisModeEl ? xAxisModeEl.value : currentXMode,
                yMode: yAxisModeEl ? yAxisModeEl.value : currentYMode,
                zMode: zAxisModeEl ? zAxisModeEl.value : currentZMode,
                // Galaxy dynamics
                rotationMode: rotationMode,
                rotationAxis: rotationAxis,
                orbitSpeed: orbitSpeed,
                orbitRadius: orbitRadius,
                particleSize: particleSize,
                particleShape: particleShape,
                particleBrightness: particleBrightness,
                visibilityDistance: visibilityDistance,
                motionEnabled: motionEnabled,
                // Axis scaling
                xAxisScale: xAxisScale,
                yAxisScale: yAxisScale,
                zAxisScale: zAxisScale,
                // Sub-particle dynamics
                clusterRadius: clusterRadius,
                subParticleScale: subParticleScale,
                particlesPerCluster: particlesPerCluster,
                subParticleMotionSpeed: subParticleMotionSpeed,
                subParticleAnimationSpeed: subParticleAnimationSpeed,
                subParticleMotionPath: subParticleMotionPath,
                subParticleShape: subParticleShape,
                // Audio reactivity
                audioReactivityEnabled: audioReactivityEnabled,
                audioReactivityStrength: audioReactivityStrength,
                globalAudioReactivity: globalAudioReactivity,
                audioFrequencyMode: audioFrequencyMode,
                // Hover interaction (renamed from mouse interaction)
                mouseInteractionEnabled: mouseInteractionEnabled,
                hoverSlowdown: hoverSlowdown,
                hoverScale: hoverScale,
                // Visual gradients
                sizeGradient: sizeGradient,
                densityGradient: densityGradient,
                bloomStrength: bloomStrength,
                // Toggle controls
                crosshairEnabled: crosshairEnabled,
                tooltipsEnabled: tooltipsEnabled,
                infoWindowEnabled: infoWindowEnabled,
                moveJoystickEnabled: moveJoystickEnabled,
                lookJoystickEnabled: lookJoystickEnabled,
                playButtonEnabled: playButtonEnabled
            };

            // Optionally include camera position if checkbox is checked
            const saveCameraCheckbox = document.getElementById('saveCameraCheckbox');
            if (saveCameraCheckbox && saveCameraCheckbox.checked && camera) {
                settings.cameraPosition = {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z
                };
                settings.cameraRotation = {
                    x: camera.rotation.x,
                    y: camera.rotation.y,
                    z: camera.rotation.z
                };
            }

            return settings;
        }

        function applySettings(settings) {
            // Visualization modes - write to Options 2 elements (galaxy* prefixed IDs)
            currentColorMode = settings.colorMode || currentColorMode;
            currentXMode = settings.xMode || currentXMode;
            currentYMode = settings.yMode || currentYMode;
            currentZMode = settings.zMode || currentZMode;

            // Update Options 2 UI elements
            const colorModeEl = document.getElementById('galaxyColorMode');
            const xAxisModeEl = document.getElementById('galaxyXAxisMode');
            const yAxisModeEl = document.getElementById('galaxyYAxisMode');
            const zAxisModeEl = document.getElementById('galaxyZAxisMode');
            if (colorModeEl) colorModeEl.value = currentColorMode;
            if (xAxisModeEl) xAxisModeEl.value = currentXMode;
            if (yAxisModeEl) yAxisModeEl.value = currentYMode;
            if (zAxisModeEl) zAxisModeEl.value = currentZMode;

            // Galaxy dynamics
            rotationMode = settings.rotationMode || rotationMode;
            rotationAxis = settings.rotationAxis || rotationAxis;
            const rotationModeEl = document.getElementById('rotationMode');
            const rotationAxisEl = document.getElementById('rotationAxis');
            if (rotationModeEl) rotationModeEl.value = rotationMode;
            if (rotationAxisEl) rotationAxisEl.value = rotationAxis;

            if (settings.orbitSpeed !== undefined) updateMotionSpeed(settings.orbitSpeed);
            if (settings.orbitRadius !== undefined) updateMotionRadius(settings.orbitRadius);
            if (settings.particleSize !== undefined) updateParticleSize(settings.particleSize);
            if (settings.particleBrightness !== undefined) updateParticleBrightness(settings.particleBrightness);
            if (settings.visibilityDistance !== undefined) updateVisibility(settings.visibilityDistance);
            if (settings.particleShape) updateParticleShape(settings.particleShape);

            // Axis scaling
            if (settings.xAxisScale !== undefined) {
                document.getElementById('xAxisScaleSlider').value = settings.xAxisScale;
                updateXAxisScale(settings.xAxisScale);
            }
            if (settings.yAxisScale !== undefined) {
                document.getElementById('yAxisScaleSlider').value = settings.yAxisScale;
                updateYAxisScale(settings.yAxisScale);
            }
            if (settings.zAxisScale !== undefined) {
                document.getElementById('zAxisScaleSlider').value = settings.zAxisScale;
                updateZAxisScale(settings.zAxisScale);
            }

            // Sub-particle dynamics
            if (settings.clusterRadius !== undefined) updateClusterSpread(settings.clusterRadius);
            if (settings.subParticleScale !== undefined) updateSubParticleSize(settings.subParticleScale);
            if (settings.particlesPerCluster !== undefined) updateSubParticleCount(settings.particlesPerCluster);
            if (settings.subParticleMotionSpeed !== undefined) updateSubParticleMotion(settings.subParticleMotionSpeed);
            if (settings.subParticleAnimationSpeed !== undefined) {
                document.getElementById('subParticleSpeedSlider').value = settings.subParticleAnimationSpeed;
                updateSubParticleSpeed(settings.subParticleAnimationSpeed);
            }
            if (settings.subParticleMotionPath) {
                document.getElementById('motionPathSelect').value = settings.subParticleMotionPath;
                updateMotionPath(settings.subParticleMotionPath);
            }
            if (settings.subParticleShape) {
                document.getElementById('subParticleShapeSelect').value = settings.subParticleShape;
                updateSubParticleShape(settings.subParticleShape);
            }

            // Audio reactivity
            if (settings.audioReactivityStrength !== undefined) updateAudioStrength(settings.audioReactivityStrength);
            if (settings.globalAudioReactivity !== undefined) updateGlobalReactivity(settings.globalAudioReactivity);
            if (settings.audioReactivityEnabled !== undefined && settings.audioReactivityEnabled !== audioReactivityEnabled) {
                toggleAudioReactivity();
            }

            // Hover interaction (renamed from mouse interaction)
            if (settings.hoverSlowdown !== undefined) {
                const speedPercentage = settings.hoverSlowdown * 100;
                document.getElementById('hoverSpeedSlider').value = speedPercentage;
                updateHoverSpeed(speedPercentage);
            }
            if (settings.hoverScale !== undefined) {
                document.getElementById('hoverScaleSlider').value = settings.hoverScale;
                updateHoverScale(settings.hoverScale);
            }
            // Legacy support for old presets
            if (settings.mouseInteractionRadius !== undefined) {
                const speedPercentage = settings.mouseInteractionRadius;
                document.getElementById('hoverSpeedSlider').value = speedPercentage;
                updateHoverSpeed(speedPercentage);
            }
            if (settings.mouseInteractionStrength !== undefined) {
                document.getElementById('hoverScaleSlider').value = settings.mouseInteractionStrength;
                updateHoverScale(settings.mouseInteractionStrength);
            }
            if (settings.mouseInteractionEnabled !== undefined && settings.mouseInteractionEnabled !== mouseInteractionEnabled) {
                toggleMouseInteraction();
            }

            // Visual gradients
            if (settings.sizeGradient !== undefined) {
                document.getElementById('sizeGradientSlider').value = settings.sizeGradient;
                updateSizeGradient(settings.sizeGradient);
            }
            if (settings.densityGradient !== undefined) {
                document.getElementById('densityGradientSlider').value = settings.densityGradient;
                updateDensityGradient(settings.densityGradient);
            }
            if (settings.bloomStrength !== undefined) {
                document.getElementById('bloomStrengthSlider').value = settings.bloomStrength;
                updateBloomStrength(settings.bloomStrength);
            }

            // Camera position (if saved in preset)
            if (settings.cameraPosition && camera) {
                camera.position.set(
                    settings.cameraPosition.x,
                    settings.cameraPosition.y,
                    settings.cameraPosition.z
                );
            }
            if (settings.cameraRotation && camera) {
                camera.rotation.set(
                    settings.cameraRotation.x,
                    settings.cameraRotation.y,
                    settings.cameraRotation.z
                );
            }

            // Audio frequency mode
            if (settings.audioFrequencyMode !== undefined) {
                document.getElementById('frequencyModeSelect').value = settings.audioFrequencyMode;
                updateFrequencyMode(settings.audioFrequencyMode);
            }

            // Motion toggle
            if (settings.motionEnabled !== undefined && settings.motionEnabled !== motionEnabled) {
                toggleMotion();
            }

            // Toggle controls
            if (settings.crosshairEnabled !== undefined && settings.crosshairEnabled !== crosshairEnabled) {
                toggleCrosshair();
            }
            if (settings.tooltipsEnabled !== undefined && settings.tooltipsEnabled !== tooltipsEnabled) {
                toggleTooltips();
            }
            if (settings.infoWindowEnabled !== undefined && settings.infoWindowEnabled !== infoWindowEnabled) {
                toggleInfoWindow();
            }
            if (settings.moveJoystickEnabled !== undefined && settings.moveJoystickEnabled !== moveJoystickEnabled) {
                toggleMoveJoystick();
            }
            if (settings.lookJoystickEnabled !== undefined && settings.lookJoystickEnabled !== lookJoystickEnabled) {
                toggleLookJoystick();
            }
            if (settings.playButtonEnabled !== undefined && settings.playButtonEnabled !== playButtonEnabled) {
                togglePlayButton();
            }

            // Apply visualization modes
            applyVisualizationModes();
        }

        function savePreset() {
            const presetName = document.getElementById('presetNameInput').value.trim();
            if (!presetName) {
                alert('Please enter a preset name');
                return;
            }

            const settings = getCurrentSettings();
            const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
            presets[presetName] = settings;
            localStorage.setItem('visualizerPresets', JSON.stringify(presets));

            updatePresetList();
            document.getElementById('presetNameInput').value = '';

            // Also save as JSON file
            savePresetAsJSON(presetName, settings);

            alert(`Preset "${presetName}" saved to browser and downloaded as JSON!`);
        }

        // Save individual preset as JSON file
        function savePresetAsJSON(presetName, settings) {
            const dataStr = JSON.stringify({ [presetName]: settings }, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `${presetName}.json`;
            link.click();

            URL.revokeObjectURL(url);
        }

        function loadPreset(presetName) {
            if (!presetName) return;

            const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
            const settings = presets[presetName];

            if (settings) {
                // All presets are already cleaned on startup
                applySettings(settings);
            }
        }

        function deletePreset() {
            const presetName = document.getElementById('presetSelect').value;
            if (!presetName) {
                alert('Please select a preset to delete');
                return;
            }

            if (confirm(`Delete preset "${presetName}"?`)) {
                const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
                delete presets[presetName];
                localStorage.setItem('visualizerPresets', JSON.stringify(presets));
                updatePresetList();
            }
        }

        function updatePresetList() {
            const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
            const select = document.getElementById('presetSelect');

            // Clear existing options except first
            select.innerHTML = '<option value="">-- Select Preset --</option>';

            // Add preset options
            Object.keys(presets).sort().forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
        }

        function setDefaultPreset() {
            const presetName = document.getElementById('presetSelect').value;
            if (!presetName) {
                alert('Please select a preset first');
                return;
            }
            localStorage.setItem('visualizerDefaultPreset', presetName);
            alert(`"${presetName}" set as default preset`);
        }

        // Export all presets as JSON file
        function exportPresetsAsJSON() {
            const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');

            if (Object.keys(presets).length === 0) {
                alert('No presets to export');
                return;
            }

            const dataStr = JSON.stringify(presets, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);

            const link = document.createElement('a');
            link.href = url;
            link.download = `visualizer-presets-${new Date().toISOString().split('T')[0]}.json`;
            link.click();

            URL.revokeObjectURL(url);
        }

        // Import presets from JSON file
        function importPresetsFromJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedPresets = JSON.parse(e.target.result);

                    // Validate structure
                    if (typeof importedPresets !== 'object') {
                        alert('Invalid preset file format');
                        return;
                    }

                    // Get existing presets
                    const existingPresets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');

                    // Count conflicts
                    const conflicts = Object.keys(importedPresets).filter(name => existingPresets[name]);

                    let shouldImport = true;
                    if (conflicts.length > 0) {
                        shouldImport = confirm(
                            `${conflicts.length} preset(s) already exist:\n${conflicts.join(', ')}\n\nOverwrite existing presets?`
                        );
                    }

                    if (shouldImport) {
                        // Merge presets (imported ones overwrite existing)
                        const mergedPresets = { ...existingPresets, ...importedPresets };
                        localStorage.setItem('visualizerPresets', JSON.stringify(mergedPresets));
                        updatePresetList();
                        alert(`Successfully imported ${Object.keys(importedPresets).length} preset(s)`);
                    }
                } catch (error) {
                    alert('Error importing presets: ' + error.message);
                }
            };

            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        // Cloud sync functions for presets (using Supabase Storage)
        async function syncPresetsToCloud() {
            const statusDiv = document.getElementById('cloudSyncStatus');
            statusDiv.textContent = 'Uploading...';
            statusDiv.style.color = '#667eea';

            try {
                const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');

                if (Object.keys(presets).length === 0) {
                    statusDiv.textContent = 'No presets to upload';
                    statusDiv.style.color = '#ea6767';
                    return;
                }

                // Convert presets to JSON blob
                const presetsBlob = new Blob([JSON.stringify(presets, null, 2)], { type: 'application/json' });

                // Upload to Supabase Storage
                const { data, error } = await supabase.storage
                    .from('visualizer-presets')
                    .upload('presets.json', presetsBlob, {
                        cacheControl: '3600',
                        upsert: true // Overwrite if exists
                    });

                if (error) throw error;

                statusDiv.textContent = `✓ Uploaded ${Object.keys(presets).length} presets`;
                statusDiv.style.color = '#10b981';

                setTimeout(() => {
                    statusDiv.textContent = '';
                }, 3000);

                console.log('Presets synced to cloud:', data);
            } catch (error) {
                console.error('Error syncing to cloud:', error);
                statusDiv.textContent = '✗ Upload failed';
                statusDiv.style.color = '#ea6767';

                // If bucket doesn't exist, show helpful message
                if (error.message.includes('Bucket not found') || error.message.includes('not found')) {
                    statusDiv.textContent = '✗ Bucket not created';
                    alert('Cloud sync requires a Storage bucket!\n\n' +
                          '1. Go to Supabase Dashboard\n' +
                          '2. Click "Storage" in sidebar\n' +
                          '3. Click "New Bucket"\n' +
                          '4. Name: visualizer-presets\n' +
                          '5. Make it Public\n' +
                          '6. Click Create');
                }
            }
        }

        async function loadPresetsFromCloud() {
            const statusDiv = document.getElementById('cloudSyncStatus');
            statusDiv.textContent = 'Downloading...';
            statusDiv.style.color = '#66c8ea';

            try {
                // Download from Supabase Storage
                const { data, error } = await supabase.storage
                    .from('visualizer-presets')
                    .download('presets.json');

                if (error) throw error;

                // Parse the JSON file
                const text = await data.text();
                const cloudPresets = JSON.parse(text);

                if (!cloudPresets || Object.keys(cloudPresets).length === 0) {
                    statusDiv.textContent = 'No cloud presets found';
                    statusDiv.style.color = '#888';
                    return;
                }

                const existingPresets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');

                // Check for conflicts
                const conflicts = Object.keys(cloudPresets).filter(name => existingPresets[name]);

                let shouldMerge = true;
                if (conflicts.length > 0) {
                    shouldMerge = confirm(
                        `Found ${Object.keys(cloudPresets).length} cloud presets.\n` +
                        `${conflicts.length} conflict(s) with local presets:\n${conflicts.join(', ')}\n\n` +
                        `Merge? (Cloud presets will overwrite local ones)`
                    );
                }

                if (shouldMerge) {
                    const mergedPresets = { ...existingPresets, ...cloudPresets };
                    localStorage.setItem('visualizerPresets', JSON.stringify(mergedPresets));
                    updatePresetList();

                    statusDiv.textContent = `✓ Downloaded ${Object.keys(cloudPresets).length} presets`;
                    statusDiv.style.color = '#10b981';

                    setTimeout(() => {
                        statusDiv.textContent = '';
                    }, 3000);

                    console.log('Presets loaded from cloud:', cloudPresets);
                }
            } catch (error) {
                console.error('Error loading from cloud:', error);
                statusDiv.textContent = '✗ Download failed';
                statusDiv.style.color = '#ea6767';

                // Check for common errors
                if (error.message.includes('Bucket not found') || error.message.includes('not found')) {
                    statusDiv.textContent = '✗ Bucket not created';
                    alert('Cloud sync requires a Storage bucket!\n\n' +
                          '1. Go to Supabase Dashboard\n' +
                          '2. Click "Storage" in sidebar\n' +
                          '3. Click "New Bucket"\n' +
                          '4. Name: visualizer-presets\n' +
                          '5. Make it Public\n' +
                          '6. Click Create');
                } else if (error.message.includes('Object not found')) {
                    statusDiv.textContent = 'No presets uploaded yet';
                    statusDiv.style.color = '#888';
                }
            }
        }

        // Show all categories (clear hiddenCategories)
        function showAllCategories() {
            hiddenCategories.clear();

            // Clear search fields
            const searchInputs = document.querySelectorAll('#fileSearchInput, #galaxySearchInput');
            searchInputs.forEach(input => {
                if (input) input.value = '';
            });

            // Clear search term and filtered file IDs
            searchTerm = '';
            searchFilteredFileIds = new Set();

            // Recreate particles so they're all visible
            if (particleSystem) {
                scene.remove(particleSystem);
                particleSystem = null;
            }
            createParticles();
            updateTagLegend();

            // Update Galaxy Menu
            if (typeof populateGalaxyTagsList === 'function') {
                populateGalaxyTagsList();
            }
            if (typeof populateGalaxyFileList === 'function') {
                populateGalaxyFileList();
            }

            console.log('All categories shown - particles recreated');
        }

        // Hide all categories (add all to hiddenCategories)
        function hideAllCategories() {
            // Get all unique categories from current files
            const allCategories = new Set();
            audioFiles.forEach(file => {
                const category = getCategoryForFile(file);
                allCategories.add(category);
            });

            // Add all categories to hidden set
            allCategories.forEach(cat => hiddenCategories.add(cat));

            // Update legend to show hidden state
            updateTagLegend();

            console.log('All categories hidden');
        }

        // Search/filter functionality
        let searchTerm = '';
        let searchFilteredFileIds = new Set(); // Track which files match current search
        let searchSelectedIndex = -1; // Track which category is selected in search results
        let searchVisibleCategories = []; // Array of visible category names in search results

        function handleSearch(value) {
            console.log('handleSearch called with:', value);
            searchTerm = value.toLowerCase().trim();

            if (!audioFiles || audioFiles.length === 0) {
                console.log('Search skipped - audioFiles not ready');
                return;
            }

            // Collect matching categories and files for legend filtering
            const matchingCategories = new Set();
            const matchingFileIds = new Set();

            // Check each file against search term
            audioFiles.forEach(file => {
                const category = getCategoryForFile(file);
                let matches = false;

                if (searchTerm === '') {
                    // Empty search - show all (except hidden categories)
                    matches = !hiddenCategories.has(category);
                    if (matches) {
                        matchingCategories.add(category);
                        matchingFileIds.add(file.id);
                    }
                } else {
                    // Check if file matches search term (filename, tags, or category)
                    const fileName = (file.name || '').toLowerCase();
                    const fileTags = (file.tags || []).map(t => t.toLowerCase()).join(' ');
                    const categoryMatches = category.toLowerCase().includes(searchTerm);

                    matches = fileName.includes(searchTerm) ||
                             fileTags.includes(searchTerm) ||
                             categoryMatches;

                    if (matches) {
                        matchingCategories.add(category);
                        matchingFileIds.add(file.id);
                    }
                }
            });

            console.log('Matching files:', matchingFileIds.size, 'Matching categories:', matchingCategories.size);

            // Store search filtered file IDs for animation loop to use
            searchFilteredFileIds = matchingFileIds;

            // Filter legend items
            filterLegendByCategories(matchingCategories);

            // Update Galaxy Menu tags, file list and count
            if (typeof populateGalaxyTagsList === 'function') {
                populateGalaxyTagsList();
            }
            if (typeof populateGalaxyFileList === 'function') {
                populateGalaxyFileList();
            }

            // Update file count in Galaxy Menu
            const galaxyFileCount = document.getElementById('galaxyFileCount');
            if (galaxyFileCount) {
                const visibleCount = searchFilteredFileIds.size > 0 ? searchFilteredFileIds.size : particles.length;
                const totalCount = audioFiles.length;
                galaxyFileCount.textContent = `${visibleCount} visible (${totalCount} total)`;
            }

            console.log(`Search applied - ${matchingFileIds.size} files match (animation loop will hide non-matching particles)`);
        }

        // Filter legend to show only matching categories
        function filterLegendByCategories(matchingCategories) {
            const legendItems = document.querySelectorAll('.tag-legend-item');
            searchVisibleCategories = []; // Reset visible categories list

            legendItems.forEach(item => {
                const categoryName = item.dataset.category;
                if (searchTerm === '' || matchingCategories.has(categoryName)) {
                    item.style.display = 'flex';
                    searchVisibleCategories.push(categoryName);
                    // Remove any existing selection highlight
                    item.style.outline = 'none';
                } else {
                    item.style.display = 'none';
                }
            });

            // Reset selection index when search changes
            searchSelectedIndex = -1;
        }

        // Handle keyboard navigation in search results
        function handleSearchKeyboard(event) {
            if (searchVisibleCategories.length === 0) return;

            if (event.key === 'ArrowDown') {
                event.preventDefault();
                searchSelectedIndex = (searchSelectedIndex + 1) % searchVisibleCategories.length;
                highlightSearchSelection();
            } else if (event.key === 'ArrowUp') {
                event.preventDefault();
                searchSelectedIndex = searchSelectedIndex <= 0 ? searchVisibleCategories.length - 1 : searchSelectedIndex - 1;
                highlightSearchSelection();
            } else if (event.key === 'Enter' || event.key === ' ') {
                event.preventDefault();
                if (searchSelectedIndex >= 0 && searchSelectedIndex < searchVisibleCategories.length) {
                    const selectedCategory = searchVisibleCategories[searchSelectedIndex];
                    // Toggle visibility of selected category
                    toggleCategoryVisibility(selectedCategory);
                } else {
                    // If no selection, blur the field to hide keyboard on mobile
                    event.target.blur();
                }
            } else if (event.key === 'Escape') {
                event.preventDefault();
                // Clear search and return focus to canvas
                document.getElementById('fileSearchInput').value = '';
                handleSearch('');
                document.getElementById('fileSearchInput').blur();
                // Request pointer lock on canvas (desktop only)
                if (!isMobileDevice) {
                    const canvas = renderer.domElement;
                    if (canvas) {
                        canvas.requestPointerLock();
                    }
                }
            }
        }

        // Highlight the selected category in search results
        function highlightSearchSelection() {
            const legendItems = document.querySelectorAll('.tag-legend-item');
            legendItems.forEach(item => {
                const categoryName = item.dataset.category;
                if (categoryName === searchVisibleCategories[searchSelectedIndex]) {
                    item.style.outline = '2px solid #667eea';
                    item.style.outlineOffset = '2px';
                    // Scroll into view
                    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                } else {
                    item.style.outline = 'none';
                }
            });
        }

        // Toggle visibility of a category (for keyboard navigation)
        function toggleCategoryVisibility(category) {
            const legendItems = document.querySelectorAll('.tag-legend-item');
            legendItems.forEach(item => {
                if (item.dataset.category === category) {
                    // Find the color dot and click it
                    const colorDot = item.querySelector('.tag-legend-color');
                    if (colorDot) {
                        colorDot.click();
                    }
                }
            });
        }

        // Clean all presets on startup - remove hiddenCategories from ALL presets
        function cleanAllPresets() {
            const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
            let cleaned = false;

            for (const presetName in presets) {
                if (presets[presetName].hiddenCategories) {
                    delete presets[presetName].hiddenCategories;
                    cleaned = true;
                }
            }

            if (cleaned) {
                localStorage.setItem('visualizerPresets', JSON.stringify(presets));
            }
        }

        // Auto-load presets from cloud on page load
        async function autoLoadPresetsFromCloud() {
            try {
                console.log('🔄 Auto-loading presets from cloud...');

                if (!supabase) {
                    console.log('⚠️ Supabase not configured, skipping cloud preset load');
                    return;
                }

                const { data, error } = await supabase.storage
                    .from('visualizer-presets')
                    .download('presets.json');

                if (error) {
                    console.log('⚠️ No cloud presets found:', error.message);
                    return;
                }

                const text = await data.text();
                const cloudPresets = JSON.parse(text);

                if (cloudPresets && Object.keys(cloudPresets).length > 0) {
                    // Merge cloud presets with local (cloud takes priority)
                    const existingPresets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
                    const mergedPresets = { ...existingPresets, ...cloudPresets };
                    localStorage.setItem('visualizerPresets', JSON.stringify(mergedPresets));
                    console.log(`✅ Auto-loaded ${Object.keys(cloudPresets).length} presets from cloud:`, Object.keys(cloudPresets));
                } else {
                    console.log('⚠️ Cloud presets file is empty');
                }
            } catch (error) {
                console.error('❌ Auto-load presets failed:', error);
            }
        }

        // Add keyboard shortcuts for quick preset loading
        function setupPresetHotkeys() {
            document.addEventListener('keydown', (e) => {
                // Only trigger if not typing in input field
                if (e.target.matches('input, textarea')) return;

                // Number keys 1-9 load presets by index
                const num = parseInt(e.key);
                if (num >= 1 && num <= 9) {
                    const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
                    const presetNames = Object.keys(presets);

                    if (presetNames.length >= num) {
                        const presetName = presetNames[num - 1];
                        console.log(`Loading preset ${num}: ${presetName}`);
                        loadPreset(presetName);

                        // Update dropdown
                        const select = document.getElementById('presetSelect');
                        if (select) select.value = presetName;

                        e.preventDefault();
                    }
                }
            });
        }

        // Initialize
        async function init() {
            cleanAllPresets();  // Clean all presets FIRST
            await autoLoadPresetsFromCloud(); // Auto-load from cloud (wait for it!)
            setupPresetHotkeys(); // Setup number key shortcuts
            initScene();
            loadData();
            updatePresetList();

            // Load default preset if set (after presets are cleaned and list is updated)
            const defaultPreset = localStorage.getItem('visualizerDefaultPreset');
            if (defaultPreset) {
                const presets = JSON.parse(localStorage.getItem('visualizerPresets') || '{}');
                if (presets[defaultPreset]) {
                    console.log(`Loading default preset: ${defaultPreset}`);
                    loadPreset(defaultPreset);
                    const select = document.getElementById('presetSelect');
                    if (select) select.value = defaultPreset;
                }
            }
        }

        init();

        // Initialize panel positions after DOM is ready
        setTimeout(() => {
            updateColorLegendPosition();
        }, 100);
    </script>
</body>
</html>
